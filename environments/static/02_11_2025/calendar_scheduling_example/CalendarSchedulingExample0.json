{
    "name": "CalendarSchedulingExample0",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "michelle",
            "steven",
            "jerry",
            "orchestrator"
        ],
        "michelle": {
            "private_information": [
                "Busy Monday 11:00-12:00"
            ],
            "goal": "Identify a one-hour meeting time on Monday between 09:00 and 17:00 that all participants can attend."
        },
        "steven": {
            "private_information": [
                "Busy Monday 09:00-09:30",
                "Busy Monday 11:30-12:00",
                "Busy Monday 13:30-14:00",
                "Busy Monday 15:30-16:00"
            ],
            "goal": "Identify a one-hour meeting time on Monday between 09:00 and 17:00 that all participants can attend."
        },
        "jerry": {
            "private_information": [
                "Busy Monday 09:00-09:30",
                "Busy Monday 10:00-11:00",
                "Busy Monday 11:30-12:30",
                "Busy Monday 13:00-14:30",
                "Busy Monday 15:30-16:00",
                "Busy Monday 16:30-17:00"
            ],
            "goal": "Identify a one-hour meeting time on Monday between 09:00 and 17:00 that all participants can attend."
        },
        "orchestrator": {
            "private_information": [],
            "goal": "Produce a solvable final plan and a PDDL domain and problem that schedule a one-hour meeting for Michelle, Steven, and Jerry on Monday within 09:00-17:00, aligned to 30-minute slots, compatible with the FastDownward/FastDownwards solver."
        }
    },
    "environment": {
        "init": {
            "time_granularity_minutes": 30,
            "meeting_duration_minutes": 60,
            "work_hours": {
                "day": "Monday",
                "start": "09:00",
                "end": "17:00"
            }
        },
        "public_information": [
            "Participants: Michelle, Steven, Jerry.",
            "Work hours: Monday 09:00-17:00.",
            "Meeting duration: 60 minutes.",
            "Time uses 24-hour format, start-inclusive and end-exclusive.",
            "Start times should align to 30-minute increments (e.g., 09:00, 09:30, 10:00, ...).",
            "There exists a feasible time that satisfies all constraints."
        ]
    },
    "workflow": {
        "michelle": {
            "analyze_calendar": {
                "input": [],
                "output": "availability_michelle",
                "system_prompt": "You are a calendar assistant. Read public context and personal busy intervals, then compute availability. Output only one JSON object wrapped in <availability></availability> without explanations.",
                "prompt": "Your name is michelle. Public information: {environment->public_information}. Your busy times: {agents->michelle->private_information}. Using a 30-minute grid and a meeting duration of {environment->init->meeting_duration_minutes} minutes on {environment->init->work_hours->day} between {environment->init->work_hours->start}-{environment->init->work_hours->end}, compute two elements: available intervals within work hours, and candidate start times that can host the full duration aligned to the 30-minute grid. Return a single JSON object with fields: participant, day, blocked (list of intervals), available (list of intervals), candidate_starts (list of HH:MM strings)."
            }
        },
        "steven": {
            "analyze_calendar": {
                "input": [],
                "output": "availability_steven",
                "system_prompt": "You are a calendar assistant. Read public context and personal busy intervals, then compute availability. Output only one JSON object wrapped in <availability></availability> without explanations.",
                "prompt": "Your name is steven. Public information: {environment->public_information}. Your busy times: {agents->steven->private_information}. Using a 30-minute grid and a meeting duration of {environment->init->meeting_duration_minutes} minutes on {environment->init->work_hours->day} between {environment->init->work_hours->start}-{environment->init->work_hours->end}, compute two elements: available intervals within work hours, and candidate start times that can host the full duration aligned to the 30-minute grid. Return a single JSON object with fields: participant, day, blocked (list of intervals), available (list of intervals), candidate_starts (list of HH:MM strings)."
            }
        },
        "jerry": {
            "analyze_calendar": {
                "input": [],
                "output": "availability_jerry",
                "system_prompt": "You are a calendar assistant. Read public context and personal busy intervals, then compute availability. Output only one JSON object wrapped in <availability></availability> without explanations.",
                "prompt": "Your name is jerry. Public information: {environment->public_information}. Your busy times: {agents->jerry->private_information}. Using a 30-minute grid and a meeting duration of {environment->init->meeting_duration_minutes} minutes on {environment->init->work_hours->day} between {environment->init->work_hours->start}-{environment->init->work_hours->end}, compute two elements: available intervals within work hours, and candidate start times that can host the full duration aligned to the 30-minute grid. Return a single JSON object with fields: participant, day, blocked (list of intervals), available (list of intervals), candidate_starts (list of HH:MM strings)."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "availability_michelle",
                    "availability_steven",
                    "availability_jerry"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You are an expert with multi-agent PDDL problems targeting the FastDownward (FastDownwards) planner. You always provide a PDDL domain and a PDDL problem file to solve the task. Enclose the PDDL domain between <domain></domain> tags and the PDDL problem between <problem></problem> tags. Keep participant actions distinct (e.g., commit-michelle, commit-steven, commit-jerry). Use classical STRIPS-compatible syntax supported by FastDownward; avoid numeric fluents and complex ADL features. Model time as discrete 30-minute slots.",
                "prompt": "Task: Schedule a 60-minute meeting for Michelle, Steven, and Jerry on Monday within 09:00-17:00 using 30-minute slots. Inputs are availability summaries from each participant: First participant: {availability_michelle} Second participant: {availability_steven} Third participant: {availability_jerry}. Harmonize time slots as objects s0900, s0930, s1000, ..., s1630, s1700, and define next relations (e.g., next s0900 s0930, next s0930 s1000, etc.). Treat valid meeting start slots as those whose next successor remains within work hours (so last valid start is 16:00). Build a domain named meeting-scheduling with types person and slot, predicates such as free ?p - person ?s - slot, next ?s - slot ?t - slot, start-slot ?s - slot, committed-michelle ?s - slot ?t - slot, committed-steven ?s - slot ?t - slot, committed-jerry ?s - slot ?t - slot, and scheduled ?s - slot. Provide distinct actions commit-michelle, commit-steven, commit-jerry that each require next ?s ?t, start-slot ?s, and that the corresponding participant is free at both ?s and ?t; each action asserts the corresponding committed predicate. Provide a finalize action that, given a consecutive pair ?s ?t with all three committed predicates true, sets scheduled ?s. In the problem, declare objects for michelle, steven, jerry (type person) and all slot objects s0900 ... s1700 (type slot). Initialize next, start-slot, and free predicates based on the three availability inputs (free holds when all three participants are available at that slot; you may also keep free per participant and require it in the commit actions). Choose a feasible earliest start time consistent with all inputs so that the problem is solvable. Output only the PDDL domain and problem wrapped in the required tags."
            }
        },
        "constraints": [
            "michelle.analyze_calendar->orchestrator.pddl",
            "steven.analyze_calendar->orchestrator.pddl",
            "jerry.analyze_calendar->orchestrator.pddl"
        ]
    }
}