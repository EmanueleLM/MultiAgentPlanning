{
    "name": "Blocksworld0",
    "author": "Human",
    "agents": {
        "number": 3,
        "names": [
            "state_annotator",
            "causal_auditor",
            "orchestrator"
        ],
        "state_annotator": {
            "private_information": [
                "You specialize in turning natural language descriptions of blocksworld into explicit, canonical facts.",
                "You never write PDDL. You only produce concise JSON state descriptions and symbol mappings for downstream components."
            ],
            "goal": "Extract the entities, predicates, and structured initial and goal facts for each scenario in a canonical form."
        },
        "causal_auditor": {
            "private_information": [
                "You audit temporal and causal consistency of the described actions and states.",
                "You remove bookkeeping shortcuts, meta-constraints like quota tokens or post-hoc penalties, and ensure no illegal step is assumed.",
                "You do not write PDDL. You only normalize and verify the state and plan facts and annotate with minimal justifications when needed."
            ],
            "goal": "Validate that the initial conditions and any provided plan steps obey the action schema and causal preconditions/effects; return a cleaned, canonical set of facts suitable for PDDL planners."
        },
        "orchestrator": {
            "private_information": [
                "You coordinate the other agents and compile the final PDDL domain and problem files from their outputs.",
                "Target the FastDownward solver with a standard STRIPS Blocksworld domain."
            ],
            "goal": "Produce final PDDL domain and problem files for each scenario, ready for FastDownward."
        }
    },
    "environment": {
        "init": {
            "max_blocks": 4,
            "visibility": 1
        },
        "public_information": [
            "You are arranging blocks into stacks using these actions: pick up a block, unstack a block from on top of another block, put down a block, stack a block on top of another block.",
            "Constraints: only one block can be picked up or unstacked at a time; the hand must be empty to pick up or unstack; a block is clear if no block is on top of it and it is not being held; you can only unstack a block if it was actually on top of the other block and is clear; once you pick up or unstack a block you are holding it; you can only put down a block you are holding; you can only stack a block if you are holding it and the target block is clear; after putting down or stacking, the hand becomes empty; when you stack a block on a second block, the second block is no longer clear.",
            "Predicates used by the planner: on(x,y), ontable(x), clear(x), holding(x), handempty."
        ],
        "scenarios": {
            "task1": {
                "blocks": [
                    "red",
                    "blue",
                    "yellow",
                    "orange"
                ],
                "initial_facts": [
                    "clear(red)",
                    "clear(blue)",
                    "clear(yellow)",
                    "handempty",
                    "on(blue,orange)",
                    "ontable(red)",
                    "ontable(orange)",
                    "ontable(yellow)"
                ],
                "goal_facts": [
                    "on(orange,blue)"
                ],
                "reference_plan": [
                    "unstack(blue,orange)",
                    "put-down(blue)",
                    "pick-up(orange)",
                    "stack(orange,blue)"
                ],
                "notes": "Blue is clear while on orange, which is consistent. Orange is not clear initially."
            },
            "task2": {
                "blocks": [
                    "red",
                    "blue",
                    "yellow",
                    "orange"
                ],
                "initial_facts": [
                    "clear(red)",
                    "clear(yellow)",
                    "handempty",
                    "on(red,blue)",
                    "on(yellow,orange)",
                    "ontable(blue)",
                    "ontable(orange)"
                ],
                "goal_facts": [
                    "on(orange,red)"
                ],
                "reference_plan": [],
                "notes": "Red is on blue and clear; yellow is on orange; blue and orange are on the table."
            }
        }
    },
    "workflow": {
        "state_annotator": {
            "annotate_task1": {
                "input": [],
                "output": "state_task1",
                "system_prompt": "Extract a compact JSON description of the blocksworld scenario. Do not emit PDDL. Output fields: blocks, initial_facts, goal_facts, reference_plan. Keep predicate names and argument ordering canonical.",
                "prompt": "Use the following public scenario to produce canonical facts and entities for task1: blocks={environment->scenarios->task1->blocks}, initial={environment->scenarios->task1->initial_facts}, goal={environment->scenarios->task1->goal_facts}, plan={environment->scenarios->task1->reference_plan}."
            },
            "annotate_task2": {
                "input": [],
                "output": "state_task2",
                "system_prompt": "Extract a compact JSON description of the blocksworld scenario. Do not emit PDDL. Output fields: blocks, initial_facts, goal_facts, reference_plan. Keep predicate names and argument ordering canonical.",
                "prompt": "Use the following public scenario to produce canonical facts and entities for task2: blocks={environment->scenarios->task2->blocks}, initial={environment->scenarios->task2->initial_facts}, goal={environment->scenarios->task2->goal_facts}, plan={environment->scenarios->task2->reference_plan}."
            }
        },
        "causal_auditor": {
            "audit_task1": {
                "input": [
                    "state_task1"
                ],
                "output": "audited_task1",
                "system_prompt": "Audit temporal and causal consistency for the provided blocksworld state and any plan steps. Remove bookkeeping shortcuts and illegal assumptions. Ensure preconditions and effects follow the standard STRIPS schema for pick-up, put-down, stack, unstack. Return a JSON with fields: blocks, initial_facts, goal_facts, plan_validity (true/false), plan_rationale (short text), normalized (true/false). Do not emit PDDL.",
                "prompt": "Validate the initial state, goal, and reference plan for task1. If something needs normalization, fix it and explain briefly."
            },
            "audit_task2": {
                "input": [
                    "state_task2"
                ],
                "output": "audited_task2",
                "system_prompt": "Audit temporal and causal consistency for the provided blocksworld state and any plan steps. Remove bookkeeping shortcuts and illegal assumptions. Ensure preconditions and effects follow the standard STRIPS schema for pick-up, put-down, stack, unstack. Return a JSON with fields: blocks, initial_facts, goal_facts, plan_validity (true/false), plan_rationale (short text), normalized (true/false). Do not emit PDDL.",
                "prompt": "Validate the initial state and goal for task2. Provide a brief note if the scenario requires any normalization. Do not invent a plan; only verify facts."
            }
        },
        "orchestrator": {
            "pddl_task1": {
                "input": [
                    "audited_task1"
                ],
                "output": "pddl_task1",
                "system_prompt": "You are an expert with PDDL and the FastDownward planner. Produce a Blocksworld STRIPS domain and a problem file for the given audited scenario. Always enclose the PDDL domain between <domain></domain> and the PDDL problem between <problem></problem>. Requirements: use :strips and :typing, no conditional effects, no quantifiers, no negative preconditions beyond classical STRIPS. Domain predicates: on ?x ?y - block, ontable ?x - block, clear ?x - block, holding ?x - block, handempty. Actions: pick-up, put-down, stack, unstack with the standard preconditions and effects. The problem must include all blocks from the audited input and encode initial_facts and goal_facts exactly as provided.",
                "prompt": "Compile the final PDDL for task1 using the audited input JSON {audited_task1}. Ensure the output is suitable for FastDownward."
            },
            "pddl_task2": {
                "input": [
                    "audited_task2"
                ],
                "output": "pddl_task2",
                "system_prompt": "You are an expert with PDDL and the FastDownward planner. Produce a Blocksworld STRIPS domain and a problem file for the given audited scenario. Always enclose the PDDL domain between <domain></domain> and the PDDL problem between <problem></problem>. Requirements: use :strips and :typing, no conditional effects, no quantifiers, no negative preconditions beyond classical STRIPS. Domain predicates: on ?x ?y - block, ontable ?x - block, clear ?x - block, holding ?x - block, handempty. Actions: pick-up, put-down, stack, unstack with the standard preconditions and effects. The problem must include all blocks from the audited input and encode initial_facts and goal_facts exactly as provided.",
                "prompt": "Compile the final PDDL for task2 using the audited input JSON {audited_task2}. Ensure the output is suitable for FastDownward."
            }
        },
        "constraints": [
            "state_annotator.annotate_task1->causal_auditor.audit_task1",
            "causal_auditor.audit_task1->orchestrator.pddl_task1",
            "state_annotator.annotate_task2->causal_auditor.audit_task2",
            "causal_auditor.audit_task2->orchestrator.pddl_task2"
        ]
    }
}