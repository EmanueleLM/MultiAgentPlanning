{
    "name": "Blocksworld1",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "scenario_analyst",
            "domain_drafter",
            "plan_checker",
            "orchestrator"
        ],
        "scenario_analyst": {
            "private_information": [],
            "goal": "Normalize the natural-language statements into a unified set of blocks, initial states, goals, and any provided plans for each scenario."
        },
        "domain_drafter": {
            "private_information": [],
            "goal": "Extract predicates, action schemas, and invariants from the public rules without emitting PDDL, keeping it solver-agnostic and ready for orchestration."
        },
        "plan_checker": {
            "private_information": [],
            "goal": "Audit temporal and causal consistency for each scenario, verify or repair plans, and explicitly remove bookkeeping shortcuts or post-hoc penalties so that transitions are justified by preconditions and effects."
        },
        "orchestrator": {
            "private_information": [],
            "goal": "Integrate the domain schema and the scenario facts to produce the final PDDL domain and two PDDL problem files targeting the FastDownward solver."
        }
    },
    "environment": {
        "init": {
            "blocks": [
                "red",
                "yellow",
                "blue",
                "orange"
            ],
            "max_stack_height": 4,
            "assume_single_hand": true
        },
        "public_information": [
            "Actions available: pick up a block; unstack a block from on top of another block; put down a block; stack a block on top of another block.",
            "You can only pick up or unstack one block at a time.",
            "You can only pick up or unstack a block if your hand is empty.",
            "You can only pick up a block if the block is on the table and the block is clear.",
            "A block is clear if the block has no other blocks on top of it and if the block is not currently held.",
            "You can only unstack a block from on top of another block if the block being unstacked was actually on top of that other block.",
            "You can only unstack a block if it is clear.",
            "Once you pick up or unstack a block, you are holding the block.",
            "You can only put down a block that you are holding.",
            "You can only stack a block on top of another block if you are holding the block being stacked.",
            "You can only stack a block on top of another block if the destination block is clear.",
            "Once you put down or stack a block, your hand becomes empty.",
            "Once you stack a block on top of a second block, the second block is no longer clear.",
            "[STATEMENT S1] Initial: red is clear; yellow is clear; hand is empty; red is on blue; yellow is on orange; blue is on the table; orange is on the table. Goal: orange is on red.",
            "[PLAN S1] unstack yellow from orange; put down yellow; pick up orange; stack orange on red.",
            "[STATEMENT S2] Initial: blue is clear; hand is empty; blue is on orange; orange is on yellow; yellow is on red; red is on the table. Goal: red is on orange and yellow is on red.",
            "[PLAN S2] No plan provided."
        ]
    },
    "workflow": {
        "scenario_analyst": {
            "parse": {
                "input": [],
                "output": "scenarios",
                "system_prompt": "Extract structured blocks-world scenarios from the public information. Identify the set of blocks, initial predicates, goals, and any listed plan steps for each scenario. Output a compact JSON with keys: blocks, scenario_1 {init, goal, plan}, scenario_2 {init, goal, plan} where plan for scenario_2 may be empty.",
                "prompt": "Your name is scenario_analyst. Read the public rules and the two statements. Return a structured summary of scenario 1 and scenario 2. Keep symbols conventional: on(x,y), ontable(x), clear(x), holding(x), handempty."
            }
        },
        "domain_drafter": {
            "schema": {
                "input": [],
                "output": "domain_schema",
                "system_prompt": "From the public rules, derive a solver-agnostic domain schema without emitting PDDL. Provide predicates and action schemas with parameters, preconditions, and effects that align with classical Blocks World and the stated constraints. Include invariants such as single-handedness and exclusivity between holding(x), ontable(x), and on(x,y).",
                "prompt": "Your name is domain_drafter. Produce a concise JSON description with keys: predicates, actions, invariants. Actions should cover pick-up(x), put-down(x), unstack(x,y), stack(x,y) with exact logical conditions implied by the rules."
            }
        },
        "plan_checker": {
            "audit": {
                "input": [
                    "scenarios",
                    "domain_schema"
                ],
                "output": "audit_report",
                "system_prompt": "Audit temporal and causal consistency using the provided schemas and scenarios. For scenario 1, verify the given plan step-by-step against preconditions and effects; repair it only if necessary. For scenario 2, assess reachability and propose a minimal consistent plan sketch if straightforward. Remove bookkeeping shortcuts such as quota tokens or post-hoc penalties; every state change must be justified by effects. Output a JSON report: scenario_1 {valid, issues, repaired_plan}, scenario_2 {reachability_notes, proposed_plan}.",
                "prompt": "Your name is plan_checker. Use the scenarios and domain schema to check plans for causal soundness and temporal feasibility, ensuring hand and clear predicates are respected at every step."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "scenarios",
                    "domain_schema",
                    "audit_report"
                ],
                "output": "pddl_blocksworld",
                "system_prompt": "You are an expert with PDDL for the FastDownward solver. Produce one PDDL domain and two PDDL problems (scenario_1 and scenario_2). The domain must include standard Blocks World predicates: (clear ?x), (on ?x ?y), (ontable ?x), (holding ?x), (handempty), and actions: pick-up, put-down, unstack, stack with correct STRIPS-style preconditions and effects. Use :requirements :strips :typing. Type: block. Include objects red yellow blue orange of type block in each problem. Enclose the domain between <domain></domain> and each problem between <problem></problem>. Ensure initial states and goals exactly match the scenarios. Target FastDownward compatibility.",
                "prompt": "Integrate the structured scenario facts and the audited report to emit a single domain and two problem files named scenario_1 and scenario_2. Keep action semantics faithful to the schema; do not invent extra predicates. Provide only the tagged PDDL artifacts."
            }
        },
        "constraints": [
            "scenario_analyst.parse->plan_checker.audit",
            "domain_drafter.schema->plan_checker.audit",
            "scenario_analyst.parse->orchestrator.pddl",
            "domain_drafter.schema->orchestrator.pddl",
            "plan_checker.audit->orchestrator.pddl"
        ]
    }
}