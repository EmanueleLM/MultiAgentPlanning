{
    "name": "Blocksworld14",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "modeler",
            "planner",
            "auditor",
            "orchestrator"
        ],
        "modeler": {
            "private_information": [
                "I specialize in formalizing blocks world as classical STRIPS with predicates: on(x,y), ontable(x), clear(x), holding(x), handempty.",
                "I capture action schemas for pick-up, put-down, stack, unstack using only preconditions, add effects, and delete effects; no derived predicates, no numeric fluents.",
                "I ensure the semantics encode the human restrictions precisely without shortcuts."
            ],
            "goal": "Provide a precise, solver-friendly action semantics for arranging blocks into stacks that matches the human restrictions."
        },
        "planner": {
            "private_information": [
                "I produce human-readable candidate plans for the given scenarios using only the four primitive actions: pick-up, put-down, stack, unstack.",
                "I do not emit PDDL; I reference actions and blocks by name and ensure sequential applicability under the stated rules."
            ],
            "goal": "Propose step-by-step candidate plans that achieve the scenario goals from the given initial states while respecting the modeled action semantics."
        },
        "auditor": {
            "private_information": [
                "I audit temporal and causal consistency of proposed plans step-by-step.",
                "I forbid bookkeeping shortcuts such as quota tokens, post-hoc penalties, or assuming effects without preconditions.",
                "I verify each precondition against the evolving state, apply effects rigorously, and return corrected traces with causal links if necessary."
            ],
            "goal": "Validate and, if needed, repair candidate plans so every action is applicable and all goals are achieved without violating the domain rules."
        },
        "orchestrator": {
            "private_information": [
                "I integrate the domain semantics and the audited plan traces to produce a final PDDL domain and a problem instance targeting the Fast Downward solver.",
                "I keep the domain STRIPS-compatible and generate a single selected scenario problem using only predicates and actions supported by Fast Downward."
            ],
            "goal": "Emit a complete PDDL domain and the selected scenario problem so Fast Downward can solve it optimally or satisficingly."
        }
    },
    "environment": {
        "init": {
            "selected_scenario": "A",
            "solver": "fast-downward",
            "plan_validation": "strict"
        },
        "public_information": [
            "World: A classical blocks world with four distinct blocks: red, blue, yellow, orange.",
            "Available actions: pick up a block; unstack a block from on top of another block; put down a block; stack a block on top of another block.",
            "Restrictions: You can only pick up or unstack one block at a time. You can only pick up or unstack a block if the hand is empty. You can only pick up a block if the block is on the table and the block is clear. A block is clear if it has no other block on top and it is not being held. You can only unstack a block from on top of another block if it is indeed on top of that block and is clear. Once you pick up or unstack a block, you are holding the block. You can only put down a block that you are holding. You can only stack a block on top of another block if you are holding the block and the destination block is clear. After putting down or stacking, the hand becomes empty. After stacking a block on another, the destination block is no longer clear.",
            "Goal: Arrange blocks to satisfy the target stacking relations for the selected scenario while respecting all restrictions.",
            "Solver target: The final output must be a STRIPS PDDL domain and a single PDDL problem for the selected scenario, compatible with Fast Downward."
        ],
        "instances": {
            "A": {
                "description": "Scenario A derived from the first statement and plan.",
                "objects": [
                    "red",
                    "blue",
                    "yellow",
                    "orange"
                ],
                "init_facts": [
                    "clear(red)",
                    "clear(orange)",
                    "handempty",
                    "on(blue, yellow)",
                    "on(orange, blue)",
                    "ontable(red)",
                    "ontable(yellow)"
                ],
                "goal_facts": [
                    "on(red, orange)",
                    "on(blue, red)"
                ],
                "reference_plan": [
                    "unstack(orange, blue)",
                    "put-down(orange)",
                    "pick-up(red)",
                    "stack(red, orange)",
                    "unstack(blue, yellow)",
                    "stack(blue, red)"
                ]
            },
            "B": {
                "description": "Scenario B derived from the second statement; plan to be synthesized.",
                "objects": [
                    "red",
                    "blue",
                    "yellow",
                    "orange"
                ],
                "init_facts": [
                    "clear(red)",
                    "clear(blue)",
                    "clear(yellow)",
                    "handempty",
                    "on(yellow, orange)",
                    "ontable(red)",
                    "ontable(blue)",
                    "ontable(orange)"
                ],
                "goal_facts": [
                    "on(orange, blue)",
                    "on(yellow, red)"
                ]
            }
        }
    },
    "workflow": {
        "modeler": {
            "action_semantics": {
                "input": [],
                "output": "semantics",
                "system_prompt": "You formalize the blocks world domain as STRIPS action schemas with predicates on, ontable, clear, holding, handempty and actions pick-up, put-down, stack, unstack. Ensure preconditions and effects exactly match the public restrictions and remain Fast Downward compatible. Do not emit PDDL; instead, provide a precise, concise schema description and any invariants.",
                "prompt": "Your name is modeler. Using the public information {environment->public_information}, produce a clean schema-level description: list of predicates; action schemas with preconditions, add effects, delete effects; safety invariants such as mutual exclusivity (e.g., holding(x) implies not ontable(x)); and notes about clear() and handempty. Keep names lowercase and consistent with classic blocks world."
            }
        },
        "planner": {
            "candidate_plans": {
                "input": [
                    "semantics"
                ],
                "output": "plans",
                "system_prompt": "You propose human-readable candidate plans for the provided scenarios using only the four primitive actions. You do not emit PDDL. Ensure each action is applicable under the modeled preconditions.",
                "prompt": "Your name is planner. Consider the scenarios in {environment->instances}. Using the semantics from {semantics}, provide candidate plans as ordered action lists for each scenario. Keep action names in the set {pick-up(x), put-down(x), unstack(x,y), stack(x,y)} and blocks in {red, blue, yellow, orange}. For Scenario A, you may start from the provided reference plan but verify it is applicable; for Scenario B, synthesize a valid plan."
            }
        },
        "auditor": {
            "consistency_audit": {
                "input": [
                    "semantics",
                    "plans"
                ],
                "output": "audited_plans",
                "system_prompt": "You are a strict temporal/causal auditor. You simulate plans step-by-step from the initial states, check every precondition, apply effects, and forbid bookkeeping shortcuts. If any step is invalid, repair with minimal edits or flag the issue and propose a corrected trace. Provide final validated traces and causal links.",
                "prompt": "Your name is auditor. Given semantics {semantics}, candidate plans {plans}, and scenarios {environment->instances}, validate and minimally repair the plans. Return per-scenario audited plans, with each step justified by applicable preconditions and with resulting states satisfying the goals. Do not introduce extra capabilities beyond the four actions."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "semantics",
                    "audited_plans"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You integrate all inputs and produce the final PDDL for Fast Downward. You must output exactly one domain and one problem for the selected scenario. Keep to classical STRIPS: predicates on(?x ?y), ontable(?x), clear(?x), holding(?x), handempty; actions pick-up, put-down, stack, unstack with correct preconditions and effects; no typing required, no conditional effects, no numeric fluents, no derived predicates. Enclose the domain between <domain></domain> and the problem between <problem></problem>.",
                "prompt": "Your name is orchestrator. The selected scenario is {environment->init->selected_scenario}. Use the semantics {semantics} and the audited plans {audited_plans} along with the scenario data {environment->instances} to produce a single STRIPS PDDL domain named blocksworld and a single PDDL problem named bw-{environment->init->selected_scenario}. Include all four blocks as objects. Ensure the initial state and goal match the selected scenario, and that the domain matches the classic restrictions so Fast Downward can solve it."
            }
        },
        "constraints": [
            "modeler.action_semantics->planner.candidate_plans",
            "modeler.action_semantics->auditor.consistency_audit",
            "planner.candidate_plans->auditor.consistency_audit",
            "auditor.consistency_audit->orchestrator.pddl",
            "modeler.action_semantics->orchestrator.pddl"
        ]
    }
}