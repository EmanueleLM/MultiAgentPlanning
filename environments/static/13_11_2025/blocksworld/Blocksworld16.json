{
    "name": "Blocksworld16",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "state_modeler",
            "instance_builder",
            "auditor",
            "orchestrator"
        ],
        "state_modeler": {
            "private_information": [
                "You specialize in formalizing domains and action schemas with precise preconditions, effects, and invariants.",
                "Target domain is classical Blocksworld with one hand and finite set of blocks.",
                "Actions: pick-up, put-down, stack, unstack.",
                "Predicates that are typically sufficient: on(x,y), ontable(x), clear(x), holding(x), handempty."
            ],
            "goal": "Provide a canonical, solver-neutral formal description of the Blocksworld actions and invariants that matches the human restrictions, ready to be consumed by downstream agents."
        },
        "instance_builder": {
            "private_information": [
                "You convert natural-language task statements into normalized instances: objects, initial facts, and goal conditions.",
                "You preserve given plans as candidate sequences associated to the relevant instance for later audit."
            ],
            "goal": "Extract two instances (A and B) from the public description, defining objects, initial state, goals, and including the provided plan for instance A."
        },
        "auditor": {
            "private_information": [
                "You audit temporal and causal consistency for plans against action schemas.",
                "You reject bookkeeping shortcuts such as quota tokens, post-hoc penalties, or unstated magical effects.",
                "You ensure single-hand constraints, clarity constraints, and stack legality are obeyed."
            ],
            "goal": "Validate or refute the provided plan for instance A step-by-step, identify exact rule violations if any, and produce a corrected minimal plan if the given plan fails. For instance B, produce causal hints and constraints that will guide planning without inventing shortcuts."
        },
        "orchestrator": {
            "private_information": [
                "You integrate the upstream model, instances, and audit report.",
                "You must output a final PDDL domain and problem files suitable for the Fast Downward solver.",
                "You ensure action names and predicate vocabulary are consistent across domain and problems."
            ],
            "goal": "Produce the final, self-contained PDDL domain and problem specifications targeting the FastDownward solver, enclosing the domain between <domain></domain> tags and each problem between <problem></problem> tags, using the integrated model and instances."
        }
    },
    "environment": {
        "init": {
            "domain": "blocks_world",
            "visibility": 1,
            "blocks": [
                "red",
                "blue",
                "yellow",
                "orange"
            ]
        },
        "public_information": [
            "Task: Arrange blocks into stacks using these actions: pick up a block; unstack a block from on top of another block; put down a block; stack a block on top of another block.",
            "Restrictions: Only one block can be picked up or unstacked at a time; pick up or unstack only if the hand is empty; pick up only if the block is on the table and clear; unstack only if the top relation is real and the unstacked block is clear; after pick up or unstack, the agent is holding the block; can only put down a block that is held; can only stack a block if holding it and the target block is clear; after put down or stack, the hand becomes empty; after stacking a block onto a second block, the second block is no longer clear; a block is clear iff it has no block on top and it is not currently held.",
            "Scenario A (Instance A) initial conditions: red is clear; blue is clear; hand is empty; red is on yellow; yellow is on orange; blue is on the table; orange is on the table. Goal: blue is on orange and orange is on yellow.",
            "Scenario A provided plan: unstack red from yellow; put down red; unstack yellow from orange; put down yellow; pick up orange; stack orange on yellow; pick up blue; stack blue on orange.",
            "Scenario B (Instance B) initial conditions: yellow is clear; hand is empty; red is on orange; blue is on red; yellow is on blue; orange is on the table. Goal: blue is on orange and orange is on yellow. No plan is provided for this instance."
        ]
    },
    "workflow": {
        "state_modeler": {
            "analyze": {
                "input": [],
                "output": "model_spec",
                "system_prompt": "You are a formal methods engineer for classical planning. Produce a compact JSON object that defines the canonical Blocksworld vocabulary and action schemas consistent with the public restrictions. Include fields: predicates (list of predicate signatures), actions (list with name, parameters, preconditions, effects where effects specify add and delete sets), invariants (state constraints such as no two things on the same block, at most one block held, exclusivity of holding vs handempty), and notes (any clarifications). Do not emit PDDL. Use names: on(x,y), ontable(x), clear(x), holding(x), handempty. Ensure that pick-up requires ontable(x) and clear(x) and handempty, put-down requires holding(x), stack requires holding(x) and clear(y), unstack requires on(x,y) and clear(x) and handempty, and that after holding a block clear(x) is false.",
                "prompt": "Your name is state_modeler. Use the following public information to ground the precise semantics and invariants of Blocksworld: {environment->public_information}. Output a single JSON object with keys predicates, actions, invariants, notes. Avoid introducing tokens or bookkeeping shortcuts."
            }
        },
        "instance_builder": {
            "compile_instances": {
                "input": [
                    "model_spec"
                ],
                "output": "instances",
                "system_prompt": "You convert natural-language descriptions into normalized planning instances. Output a JSON object with key instances containing two entries: instance_a and instance_b. Each instance must have fields: name, objects (list of block names), init (list of ground atoms using the model predicates), goal (list of goal atoms), and plan (list of action strings) where plan is provided for instance_a and is an empty list for instance_b. Keep vocabulary consistent with the model_spec. Do not emit PDDL.",
                "prompt": "Your name is instance_builder. From the public information, extract two instances with objects red, blue, yellow, orange. For Instance A, set init to: on(red,yellow), on(yellow,orange), ontable(blue), ontable(orange), clear(red), clear(blue), handempty. For Instance A, set goal to: on(blue,orange), on(orange,yellow). For Instance A, include the provided plan steps as a list in chronological order using action names pick-up, put-down, stack, unstack with parameters as needed. For Instance B, set init to: on(yellow,blue), on(blue,red), on(red,orange), ontable(orange), clear(yellow), handempty. For Instance B, set the same goal as Instance A and set plan to an empty list. Use the model_spec predicate names exactly."
            }
        },
        "auditor": {
            "audit_plans": {
                "input": [
                    "model_spec",
                    "instances"
                ],
                "output": "audit_report",
                "system_prompt": "You are a temporal and causal consistency auditor. Using the provided model_spec and instances, check the Instance A plan step-by-step. Verify that each action's preconditions hold in the current state, then apply effects to update the state; record any violations precisely with the failing step and predicate context; reject bookkeeping shortcuts and ensure hand capacity, clarity, and on/ontable exclusivity constraints are enforced. If violations occur, produce a corrected minimal plan consistent with the model; if no violations, confirm validity. For Instance B, do not fabricate a plan; instead produce search_hints that list intended subgoals, helpful actions, and causal links that will likely be required. Output a JSON object with keys: instance_a {status, issues (list), validated_plan (list)}, instance_b {search_hints (object with subgoals, helpful_actions, causal_links)}.",
                "prompt": "Your name is auditor. Audit the provided plan for Instance A against the model and initial state. Ensure there is no step that assumes holding more than one block, moving a non-clear block, stacking onto a non-clear block, or skipping the handempty requirement. For Instance B, provide structured guidance only, not a full plan."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "model_spec",
                    "instances",
                    "audit_report"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You are an expert in multi-source planning integration. Integrate model_spec, instances, and audit_report to produce a final PDDL domain and problem files targeting the Fast Downward (FastDownward) solver. Enclose the PDDL domain between <domain></domain> tags and each problem between <problem></problem> tags. Use a single domain named blocksworld16. Keep predicates and action schemas consistent with model_spec and the human restrictions: pick-up(x) requires ontable(x) and clear(x) and handempty and makes holding(x) true, handempty false, clear(x) false, ontable(x) false; put-down(x) requires holding(x) and makes ontable(x) true, clear(x) true, handempty true, holding(x) false; stack(x,y) requires holding(x) and clear(y) and makes on(x,y) true, clear(y) false, handempty true, holding(x) false, clear(x) false, ontable(x) false; unstack(x,y) requires on(x,y) and clear(x) and handempty and makes holding(x) true, clear(y) true, handempty false, on(x,y) false, clear(x) false. Generate two problem files: problem blocksworld16-a using Instance A init and goal; problem blocksworld16-b using Instance B init and goal. Do not include plans inside the PDDL; provide only domain and problem specifications with consistent objects and initial facts.",
                "prompt": "Orchestrate the provided inputs to synthesize the final PDDL. Use objects red blue yellow orange. For problem blocksworld16-a, set init to on(red,yellow) on(yellow,orange) ontable(blue) ontable(orange) clear(red) clear(blue) handempty and goal to on(blue,orange) on(orange,yellow). For problem blocksworld16-b, set init to on(yellow,blue) on(blue,red) on(red,orange) ontable(orange) clear(yellow) handempty and the same goal. Ensure the output has exactly one <domain> block and two <problem> blocks, each syntactically valid for FastDownward."
            }
        },
        "constraints": [
            "state_modeler.analyze->instance_builder.compile_instances",
            "state_modeler.analyze->auditor.audit_plans",
            "instance_builder.compile_instances->auditor.audit_plans",
            "state_modeler.analyze->orchestrator.pddl",
            "instance_builder.compile_instances->orchestrator.pddl",
            "auditor.audit_plans->orchestrator.pddl"
        ]
    }
}