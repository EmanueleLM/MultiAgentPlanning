{
    "name": "Blocksworld2",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "state_analyst",
            "scenario_curator",
            "consistency_auditor",
            "orchestrator"
        ],
        "state_analyst": {
            "private_information": [
                "I formalize natural language rules into STRIPS-style predicates and action schemas.",
                "I decide on canonical symbol names, typing, and invariants for blocks world."
            ],
            "goal": "Produce a precise, solver-ready conceptual model of the blocks world actions, states, and invariants without emitting PDDL."
        },
        "scenario_curator": {
            "private_information": [
                "I extract objects, initial states, and goals for each scenario and normalize them into a consistent symbol set.",
                "I resolve naming, synonymy, and role ambiguities across descriptions."
            ],
            "goal": "Provide clean, normalized initial and goal states for each scenario and list the available objects, without emitting PDDL."
        },
        "consistency_auditor": {
            "private_information": [
                "I audit temporal and causal consistency of described actions and plans against the formal rules.",
                "I reject bookkeeping shortcuts such as tokens, post-hoc penalties, or omissions of required preconditions and effects."
            ],
            "goal": "Validate that the described plans and rules are causally and temporally consistent and report any violations; ensure no non-causal bookkeeping shortcuts are used."
        },
        "orchestrator": {
            "private_information": [
                "I integrate analyses to produce the final PDDL domain and problem files.",
                "Target solver is Fast Downward; keep to STRIPS-compatible features."
            ],
            "goal": "Generate a correct PDDL domain and problem files for the provided scenarios, suitable for Fast Downward."
        }
    },
    "environment": {
        "init": {
            "objects": [
                "red",
                "yellow",
                "blue",
                "orange"
            ],
            "visibility": "global",
            "domain": "blocksworld"
        },
        "public_information": [
            "Available primitive actions: pick up a block, unstack a block from on top of another block, put down a block, stack a block on top of another block.",
            "Restrictions: only one block can be picked up or unstacked at a time; the hand must be empty to pick up or unstack; you can only pick up a block that is on the table and clear; a block is clear if no block is on top of it and it is not currently being held; unstacking is only possible if the top relationship actually holds and the block being unstacked is clear; after pick up or unstack you are holding that block; you can only put down a block you are holding; you can only stack a block if you are holding it and the destination block is clear; after put down or stack the hand becomes empty; stacking onto a block makes that destination block not clear.",
            "Scenario A initial state: clear(blue), handempty, on(blue, orange), on(orange, yellow), on(yellow, red), ontable(red).",
            "Scenario A goal: on(red, orange) and on(yellow, red).",
            "Scenario A provided plan (natural language order): unstack the blue block from on top of the orange block; put down the blue block; unstack the orange block from on top of the yellow block; put down the orange block; unstack the yellow block from on top of the red block; stack the yellow block on top of the blue block; pick up the red block; stack the red block on top of the orange block; unstack the yellow block from on top of the blue block; stack the yellow block on top of the red block.",
            "Scenario B initial state: clear(yellow), handempty, on(red, orange), on(orange, blue), on(yellow, red), ontable(blue).",
            "Scenario B goal: on(red, yellow) and on(yellow, blue).",
            "Scenario B plan: not provided; must be found by the planner."
        ]
    },
    "workflow": {
        "state_analyst": {
            "analysis": {
                "input": [],
                "output": "formal_model_draft",
                "system_prompt": "You convert natural language blocks world rules into a clean STRIPS-style specification without emitting PDDL. Focus on the canonical predicate set, action schemas, preconditions, effects, state invariants, and typing. Keep symbols short and conventional for Fast Downward compatibility.",
                "prompt": "Your name is state_analyst. Use the public information to define the conceptual model of the domain. Provide the list of predicates (e.g., clear(x), on(x,y), ontable(x), holding(x), handempty), action schemas (pickup, putdown, stack, unstack) with precise preconditions and effects, and key invariants such as uniqueness of support and at most one in-hand block. Do not output PDDL; provide a concise, unambiguous model draft. Public information: {environment->public_information}. Your knowledge: {agents->state_analyst->private_information}. Global goal: {agents->orchestrator->goal}."
            }
        },
        "scenario_curator": {
            "curate": {
                "input": [],
                "output": "scenarios_normalized",
                "system_prompt": "You normalize scenario descriptions into a consistent symbol set and structured facts without emitting PDDL.",
                "prompt": "Your name is scenario_curator. Extract the object set and normalize the initial and goal facts for Scenario A and Scenario B using symbols consistent with the formal model draft (e.g., objects: red yellow blue orange of type block). Report each scenario as a list of atoms for init and goal. Do not output PDDL. Public information: {environment->public_information}. Your knowledge: {agents->scenario_curator->private_information}."
            }
        },
        "consistency_auditor": {
            "audit": {
                "input": [
                    "formal_model_draft",
                    "scenarios_normalized"
                ],
                "output": "audit_report",
                "system_prompt": "You audit temporal and causal consistency and remove bookkeeping shortcuts; you verify that described plans obey preconditions and effects and that no non-causal tokens or post-hoc penalties are used.",
                "prompt": "Your name is consistency_auditor. Using the formal model draft and the normalized scenarios, check that Scenario A's provided plan respects action preconditions, effects, and invariants, and identify any violations or unnecessary steps. For Scenario B, confirm the problem is solvable under the rules and note any special considerations. Do not output PDDL. Inputs: {formal_model_draft} and {scenarios_normalized}. Your knowledge: {agents->consistency_auditor->private_information}."
            }
        },
        "orchestrator": {
            "compile_pddl_A": {
                "input": [
                    "formal_model_draft",
                    "scenarios_normalized",
                    "audit_report"
                ],
                "output": "pddl_fd_A",
                "system_prompt": "You are an expert in compiling final PDDL for Fast Downward. You must output a single PDDL domain and a single PDDL problem for Scenario A. Ensure STRIPS compatibility, avoid numeric fluents and conditional effects; use standard predicates and types.",
                "prompt": "Produce the final PDDL domain and the PDDL problem for Scenario A, suitable for Fast Downward. Use a single domain with actions pickup, putdown, stack, unstack; predicates clear, on, ontable, holding, handempty; type block for objects red yellow blue orange. Encode the initial state and goal for Scenario A from the curated scenarios. Keep preconditions and effects consistent with the formal model and the auditor's findings. Enclose the domain between <domain></domain> and the problem between <problem></problem>."
            },
            "compile_pddl_B": {
                "input": [
                    "formal_model_draft",
                    "scenarios_normalized",
                    "audit_report"
                ],
                "output": "pddl_fd_B",
                "system_prompt": "You are an expert in compiling final PDDL for Fast Downward. You must output a single PDDL domain and a single PDDL problem for Scenario B. Ensure STRIPS compatibility, avoid numeric fluents and conditional effects; use standard predicates and types.",
                "prompt": "Produce the final PDDL domain and the PDDL problem for Scenario B, suitable for Fast Downward. Use the same domain as in Scenario A with actions pickup, putdown, stack, unstack; predicates clear, on, ontable, holding, handempty; type block for objects red yellow blue orange. Encode the initial state and goal for Scenario B from the curated scenarios. The problem should be solvable by Fast Downward. Enclose the domain between <domain></domain> and the problem between <problem></problem>."
            }
        },
        "constraints": [
            "state_analyst.analysis->consistency_auditor.audit",
            "scenario_curator.curate->consistency_auditor.audit",
            "state_analyst.analysis->orchestrator.compile_pddl_A",
            "scenario_curator.curate->orchestrator.compile_pddl_A",
            "consistency_auditor.audit->orchestrator.compile_pddl_A",
            "state_analyst.analysis->orchestrator.compile_pddl_B",
            "scenario_curator.curate->orchestrator.compile_pddl_B",
            "consistency_auditor.audit->orchestrator.compile_pddl_B"
        ]
    }
}