{
    "name": "Blocksworld21",
    "author": "Human",
    "agents": {
        "number": 5,
        "names": [
            "translator",
            "modeler",
            "planner",
            "auditor",
            "orchestrator"
        ],
        "translator": {
            "private_information": [
                "I normalize natural language descriptions of blocks-world tasks into explicit objects, states, and goals.",
                "I resolve synonyms and ensure consistent symbol names across scenarios."
            ],
            "goal": "Extract and normalize all facts, objects, and goals for each scenario so downstream agents can reason deterministically."
        },
        "modeler": {
            "private_information": [
                "I draft a formal symbolic model of predicates, action schemas, and invariants, without emitting PDDL.",
                "I ensure action schemas reflect the exact restrictions stated by the user."
            ],
            "goal": "Produce a clean, solver-agnostic, structured specification of states, predicates, and actions that faithfully encode the problem constraints."
        },
        "planner": {
            "private_information": [
                "I propose candidate plans as sequences of grounded actions adhering to the modeled preconditions and effects.",
                "I do not assume hidden shortcuts such as quota tokens or bookkeeping penalties."
            ],
            "goal": "Synthesize a causal sequence of actions for each scenario that achieves the goal from the initial state."
        },
        "auditor": {
            "private_information": [
                "I audit temporal and causal consistency, check hand occupancy and clarity invariants at every step, and remove bookkeeping shortcuts or post-hoc fixes.",
                "I flag violations and repair plans when deterministically possible."
            ],
            "goal": "Validate and, if needed, minimally correct the candidate plans to ensure strict adherence to the action restrictions and invariants."
        },
        "orchestrator": {
            "private_information": [
                "I integrate the normalized facts, the formal model, and the audited plans.",
                "I am responsible for producing the final PDDL domain and problem files targeting the FastDownward solver."
            ],
            "goal": "Compile a correct PDDL domain and corresponding PDDL problem(s) that encode the scenarios precisely, suitable for FastDownward."
        }
    },
    "environment": {
        "init": {
            "blocks": [
                "blue",
                "yellow",
                "orange",
                "red"
            ],
            "hand": "hand",
            "visibility": "full",
            "solver": "FastDownward"
        },
        "public_information": [
            "You are arranging blocks into stacks using the following actions: pick up a block, unstack a block from on top of another block, put down a block, stack a block on top of another block.",
            "Restrictions: (1) Only one block may be picked up or unstacked at a time. (2) You may only pick up or unstack if your hand is empty. (3) You may only pick up a block if it is on the table and clear. (4) You may only unstack a block if it was actually on top of the other block. (5) You may only unstack a block if it is clear. (6) After pick up or unstack you are holding that block. (7) You may only put down a block you are holding. (8) You may only stack a block if you are holding it and the destination block is clear. (9) After put down or stack, the hand becomes empty. (10) After stacking a block on a second block, the second block is no longer clear.",
            "Scenario S1 initial conditions: blue is clear; yellow is clear; hand is empty; orange is on top of red; yellow is on top of orange; red is on the table; blue is on the table.",
            "Scenario S1 goal: blue is on top of orange and yellow is on top of red.",
            "Scenario S1 reference plan (natural language): unstack the yellow block from on top of the orange block; stack the yellow block on top of the blue block; unstack the orange block from on top of the red block; put down the orange block; unstack the yellow block from on top of the blue block; stack the yellow block on top of the red block; pick up the blue block; stack the blue block on top of the orange block.",
            "Scenario S2 initial conditions: red is clear; blue is clear; hand is empty; red is on top of yellow; yellow is on top of orange; blue is on the table; orange is on the table.",
            "Scenario S2 goal: blue is on top of orange and yellow is on top of red.",
            "All agents must preserve invariants: a block cannot be both on the table and on another block; at most one block is held at a time; a held block is not clear; a block with something on it is not clear; the hand is empty iff no block is held."
        ]
    },
    "workflow": {
        "translator": {
            "extract_facts": {
                "input": [],
                "output": "facts_normalized",
                "system_prompt": "You are a precise extractor. Convert public information into normalized objects, predicates, and goals for scenarios S1 and S2. Use consistent symbols: blocks = {blue, yellow, orange, red}; predicates = clear(x), on(x,y), ontable(x), holding(x), handempty. For each scenario produce initial facts and goal facts, preserving only what is explicitly stated or logically implied (e.g., if on(x,y) then not ontable(x)). Do not emit PDDL; emit a concise, unambiguous structured summary.",
                "prompt": "Extract normalized facts and goals for scenarios S1 and S2 from the public information. Resolve any surface-language variations into canonical predicates and list all objects."
            }
        },
        "modeler": {
            "formalize": {
                "input": [
                    "facts_normalized"
                ],
                "output": "formal_model",
                "system_prompt": "You are a formal modeler. Produce a solver-agnostic, structured definition of the blocks-world: list predicates, action schemas, and state invariants that exactly implement the user's restrictions. Use action schemas named: pickup(x), putdown(x), unstack(x,y), stack(x,y). Specify for each action: preconditions and effects (add and delete lists). Do not emit PDDL; keep it as a clear, structured description suitable for compilation into PDDL later.",
                "prompt": "From the normalized facts, define predicates, action schemas, and invariants that reflect the allowed actions and restrictions. Use canonical names and ensure there are no hidden shortcuts."
            }
        },
        "planner": {
            "synthesize_plan": {
                "input": [
                    "formal_model",
                    "facts_normalized"
                ],
                "output": "candidate_plans",
                "system_prompt": "You are a symbolic planner operating over the provided structured model. For each scenario, propose a step-by-step plan as grounded actions that obey all preconditions and effects. Do not emit PDDL. Use only the four actions with correct arguments and respect hand occupancy and clarity constraints at every step.",
                "prompt": "Produce candidate plans for S1 and S2 as sequences of grounded actions pickup(x), putdown(x), unstack(x,y), stack(x,y) that achieve the stated goals."
            }
        },
        "auditor": {
            "causal_audit": {
                "input": [
                    "candidate_plans",
                    "formal_model",
                    "facts_normalized"
                ],
                "output": "audited_plans",
                "system_prompt": "You are a rigorous temporal/causal auditor. Validate each action in each plan against the model and initial state, step by step, checking preconditions, effects, hand occupancy, clarity, and invariants. Remove bookkeeping shortcuts such as quota tokens or post-hoc penalties, and either repair minimal violations deterministically or flag them. Return the corrected plans with rationale per edit.",
                "prompt": "Audit the candidate plans for S1 and S2. If a step violates constraints, minimally correct it or explain why the plan cannot be repaired. Return cleaned plans with explicit action sequences."
            }
        },
        "orchestrator": {
            "compile_pddl": {
                "input": [
                    "formal_model",
                    "facts_normalized",
                    "audited_plans"
                ],
                "output": "pddl_compilation",
                "system_prompt": "You are an expert with PDDL for the FastDownward solver. Integrate the formal model and normalized facts to produce a single reusable PDDL domain for BlocksWorld and two PDDL problem files (one for S1 and one for S2). Use only STRIPS-compatible constructs accepted by FastDownward. Domain must include predicates: (clear ?x - block) (on ?x - block ?y - block) (ontable ?x - block) (holding ?x - block) (handempty). Actions: pickup, putdown, unstack, stack with standard preconditions/effects matching the user's restrictions. Problems must list objects {blue yellow orange red}, initial facts for each scenario, and the goal conjuncts. Enclose the PDDL domain between <domain></domain> tags and each PDDL problem between separate <problem></problem> tags. Do not include anything other than the PDDL artifacts.",
                "prompt": "Compile the final PDDL domain and two problem files for scenarios S1 and S2 using the integrated inputs. Target FastDownward; keep to :strips and, if used, :typing. Ensure initial states and goals match the normalized facts. Output exactly: <domain>...</domain><problem>...</problem><problem>...</problem>."
            }
        },
        "constraints": [
            "translator.extract_facts->modeler.formalize",
            "translator.extract_facts->planner.synthesize_plan",
            "modeler.formalize->planner.synthesize_plan",
            "planner.synthesize_plan->auditor.causal_audit",
            "modeler.formalize->auditor.causal_audit",
            "auditor.causal_audit->orchestrator.compile_pddl",
            "modeler.formalize->orchestrator.compile_pddl",
            "translator.extract_facts->orchestrator.compile_pddl"
        ]
    }
}