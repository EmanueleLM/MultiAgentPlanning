{
    "name": "Blocksworld3",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "modeler",
            "planner",
            "auditor",
            "orchestrator"
        ],
        "modeler": {
            "private_information": [
                "I convert natural language rules into a consistent symbolic description of Blocksworld.",
                "I identify objects, predicates, action schemas, and state/goal facts for each scenario.",
                "I standardize naming and avoid hidden assumptions beyond what is stated."
            ],
            "goal": "Extract a clean, unambiguous symbolic schema of the Blocksworld domain and the two scenarios (initial states and goals) from the public description."
        },
        "planner": {
            "private_information": [
                "I propose plan candidates as sequences of grounded actions using the modeler's schema.",
                "I do not emit PDDL; I express plans as lists of steps using action names and arguments."
            ],
            "goal": "Provide candidate action sequences for each scenario that likely achieve the goals under the given rules."
        },
        "auditor": {
            "private_information": [
                "I audit temporal and causal consistency of plans step-by-step.",
                "I enforce preconditions, effects, and invariants; I remove bookkeeping shortcuts (e.g., token quotas, post-hoc penalties) and illegal steps.",
                "I correct or complete plans minimally when violations are found and explain the fixes."
            ],
            "goal": "Validate and, if needed, repair plans for each scenario so that every step satisfies the rules and the final state achieves the goals."
        },
        "orchestrator": {
            "private_information": [],
            "goal": "Integrate the symbolic schema and audited plans to produce a final PDDL domain and PDDL problem files suitable for the FastDownward solver."
        }
    },
    "environment": {
        "init": {
            "domain": "blocksworld",
            "objects": [
                "red",
                "orange",
                "yellow",
                "blue"
            ],
            "scenarios": {
                "s1": {
                    "initial_conditions": [
                        "clear(yellow)",
                        "handempty",
                        "on(red, orange)",
                        "on(orange, blue)",
                        "on(yellow, red)",
                        "ontable(blue)"
                    ],
                    "goal_conditions": [
                        "on(red, yellow)",
                        "on(yellow, blue)"
                    ]
                },
                "s2": {
                    "initial_conditions": [
                        "clear(orange)",
                        "clear(yellow)",
                        "handempty",
                        "on(blue, red)",
                        "on(orange, blue)",
                        "ontable(red)",
                        "ontable(yellow)"
                    ],
                    "goal_conditions": [
                        "on(blue, red)",
                        "on(yellow, orange)"
                    ]
                }
            }
        },
        "public_information": [
            "Entities: blocks = {red, orange, yellow, blue}. One robotic hand that can hold at most one block.",
            "Actions available: pick-up(x), unstack(x, y), put-down(x), stack(x, y).",
            "Action restrictions and semantics:",
            "- You can only pick up or unstack one block at a time.",
            "- You can only pick up or unstack a block if your hand is empty.",
            "- pick-up(x) is allowed only if ontable(x) and clear(x).",
            "- unstack(x, y) is allowed only if on(x, y) and clear(x).",
            "- After pick-up(x) or unstack(x, y), holding(x) becomes true and handempty becomes false.",
            "- put-down(x) is allowed only if holding(x). Effects: ontable(x), clear(x), handempty, and not holding(x).",
            "- stack(x, y) is allowed only if holding(x) and clear(y). Effects: on(x, y), clear(x) becomes true, y becomes not clear, handempty becomes true, and not holding(x).",
            "- Once x is stacked on y, clear(y) becomes false.",
            "Scenario 1 initial conditions: clear(yellow), handempty, on(red, orange), on(orange, blue), on(yellow, red), ontable(blue). Goal: on(red, yellow) and on(yellow, blue).",
            "Scenario 1 plan provided (candidate): unstack(yellow, red); put-down(yellow); unstack(red, orange); put-down(red); unstack(orange, blue); put-down(orange); pick-up(yellow); stack(yellow, blue); pick-up(red); stack(red, yellow).",
            "Scenario 2 initial conditions: clear(orange), clear(yellow), handempty, on(blue, red), on(orange, blue), ontable(red), ontable(yellow). Goal: on(blue, red) and on(yellow, orange).",
            "Scenario 2 plan: not provided and must be proposed and audited."
        ]
    },
    "workflow": {
        "modeler": {
            "extract_schema": {
                "input": [],
                "output": "lifted_schema",
                "system_prompt": "You are a formalization specialist for classical planning domains. Build a symbolic, implementation-agnostic schema for the Blocksworld described below. Represent: (1) objects with clear names; (2) predicates with argument names; (3) action schemas (pick-up, unstack, put-down, stack) with explicit preconditions and add/delete effects consistent with the description; (4) initial and goal facts for both scenarios s1 and s2; (5) invariants such as anti-cycles (no block is on itself) and single support per block. Do NOT output PDDL; use a concise, structured JSON-like notation.",
                "prompt": "Public description: {environment->public_information}. Extract a lifted schema with predicates {on(x,y), ontable(x), clear(x), holding(x), handempty}, and provide the two scenario states and goals. Ensure the action semantics match the restrictions exactly. Avoid assumptions beyond what is stated. Output keys: {predicates, actions, objects, scenarios}."
            }
        },
        "planner": {
            "propose_plans": {
                "input": [
                    "lifted_schema"
                ],
                "output": "candidate_plans",
                "system_prompt": "You are a classical planner working at the action-sequence level. Using the provided symbolic schema, propose grounded action sequences that reach each scenario's goal from its initial state when possible. Do not emit PDDL. Keep action names consistent with the schema and use tuples like action(arg1, arg2). Prefer minimal or near-minimal plans, but prioritize correctness over optimality.",
                "prompt": "Use the schema: {lifted_schema}. For scenario s1, copy the provided plan as a candidate if it is consistent; otherwise propose a corrected version. For scenario s2, propose a complete plan. Output a JSON object with keys {s1, s2}, where each value is a list of actions like [\"unstack(yellow, red)\", \"put-down(yellow)\", ...]."
            }
        },
        "auditor": {
            "temporal_audit": {
                "input": [
                    "lifted_schema",
                    "candidate_plans"
                ],
                "output": "audited_plans",
                "system_prompt": "You are a temporal/causal consistency auditor. Simulate each plan step-by-step using the provided schema. Enforce all preconditions, effects, and invariants, and disallow bookkeeping shortcuts (e.g., token quotas, post-hoc penalties, or implicit clears). If a step is illegal, minimally repair the plan by inserting, deleting, or replacing steps. Ensure the final plan achieves the goal. Provide a justification for every change. Your output is strictly structured JSON with no extraneous prose.",
                "prompt": "Audit the candidate plans with the schema: {lifted_schema} and {candidate_plans}. For each scenario, return: {valid: true|false, plan: [steps], notes: [justifications]}. Guarantee that the returned plan is valid and goal-achieving, or explain why not if impossible under the given rules."
            }
        },
        "orchestrator": {
            "synthesize_pddl": {
                "input": [
                    "lifted_schema",
                    "audited_plans"
                ],
                "output": "pddl_blocksworld3",
                "system_prompt": "You are an expert in PDDL and FastDownward. Produce a single PDDL domain for the standardized Blocksworld and two PDDL problem instances, one for each scenario (s1 and s2). Your output must contain exactly one <domain>...</domain> block and two <problem>...</problem> blocks (one per scenario). Ensure classical STRIPS-compatible typing and predicates: on ?x ?y, ontable ?x, clear ?x, holding ?x, handempty. Actions: pick-up ?x, put-down ?x, unstack ?x ?y, stack ?x ?y with precise preconditions and effects per the restrictions. Use a single :types block with type block. Problems should declare the four blocks as objects of type block and include initial and goal facts matching the scenarios. Target FastDownward compatibility (no derived predicates, no action costs).",
                "prompt": "Integrate: Schema = {lifted_schema}; Audited plans = {audited_plans}. Output the final PDDL domain and two problems. Enclose the domain in <domain></domain>. Enclose scenario s1 in a <problem>...</problem> block named bworld-s1; enclose scenario s2 in a second <problem>...</problem> block named bworld-s2. Ensure there are no contradictory facts and that initial states reflect the public description. Do not include explanations or comments\u2014only the PDDL wrapped in the required tags."
            }
        },
        "constraints": [
            "modeler.extract_schema->planner.propose_plans",
            "modeler.extract_schema->auditor.temporal_audit",
            "planner.propose_plans->auditor.temporal_audit",
            "auditor.temporal_audit->orchestrator.synthesize_pddl",
            "modeler.extract_schema->orchestrator.synthesize_pddl"
        ]
    }
}