{
    "name": "Blocksworld8",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "analyst",
            "plan_writer",
            "auditor",
            "orchestrator"
        ],
        "analyst": {
            "private_information": [
                "I formalize BlocksWorld domains, states, and goals.",
                "I extract structured objects, predicates, and scenario instances from text.",
                "I do not write PDDL; I produce normalized JSON world models."
            ],
            "goal": "Produce a clean, normalized world model for all scenarios, including objects, predicates, initial states, and goals, consistent with BlocksWorld rules."
        },
        "plan_writer": {
            "private_information": [
                "I produce stepwise plans using only legal actions: pickup, putdown, stack, unstack.",
                "I avoid making assumptions not supported by the world model.",
                "I do not write PDDL; I return plans in structured JSON."
            ],
            "goal": "Propose executable plans for each scenario that obey the preconditions and effects of the allowed actions."
        },
        "auditor": {
            "private_information": [
                "I audit temporal and causal consistency of plans.",
                "I remove bookkeeping shortcuts and artifacts such as quota tokens, post-hoc penalties, or hidden assumptions.",
                "I ensure each step is supported by valid preconditions and produces intended effects without contradictions.",
                "I do not write PDDL; I return corrected, verified plans and causal links."
            ],
            "goal": "Validate and, if necessary, correct the candidate plans so that they strictly adhere to BlocksWorld dynamics and scenario goals."
        },
        "orchestrator": {
            "private_information": [
                "I integrate the audited world model and plans into a single PDDL domain and multiple PDDL problems targeting the Fast Downward solver.",
                "I keep actions aligned with the canonical BlocksWorld operators: pick-up, put-down, stack, unstack.",
                "I ensure final outputs are enclosed in <domain></domain> and <problem></problem> tags."
            ],
            "goal": "Produce the final PDDL domain and problem files for Fast Downward, covering all scenarios."
        }
    },
    "environment": {
        "init": {
            "blocks": [
                "red",
                "blue",
                "yellow",
                "orange"
            ],
            "hand": "hand",
            "visibility": "full",
            "max_scenarios": 2
        },
        "public_information": [
            "You can perform these actions: pick up a block; unstack a block from on top of another block; put down a block; stack a block on top of another block.",
            "Action constraints: only one block can be picked up or unstacked at a time; pick up or unstack only if the hand is empty; pick up only if the block is on the table and clear; unstack only if the top block was really on the other block and is clear; after pick up or unstack you are holding the block; you can only put down a block you are holding; you can only stack a block you are holding; you can only stack onto a block that is clear; after put down or stack the hand becomes empty; after stacking onto a block, that supporting block is no longer clear.",
            "Scenario 1 initial state: blue is clear; orange is clear; hand is empty; orange is on yellow; yellow is on red; red is on the table; blue is on the table.",
            "Scenario 1 goal: red is on orange; blue is on red; yellow is on blue.",
            "Scenario 1 user-proposed plan: unstack orange from yellow; put down orange; unstack yellow from red; put down yellow; pick up red; stack red on orange; pick up blue; stack blue on red; pick up yellow; stack yellow on blue.",
            "Scenario 2 initial state: orange is clear; yellow is clear; hand is empty; orange is on blue; yellow is on red; red is on the table; blue is on the table.",
            "Scenario 2 goal: red is on yellow; blue is on orange."
        ]
    },
    "workflow": {
        "analyst": {
            "analyze_spec": {
                "input": [],
                "output": "world_model",
                "system_prompt": "You convert the provided BlocksWorld text into a normalized world model. Output strict JSON with keys: objects {blocks: [names], hand: string}, predicates: [\"on(x,y)\", \"ontable(x)\", \"clear(x)\", \"holding(x)\", \"handempty\"], actions describing preconditions and effects for pickup, putdown, stack, unstack, and scenarios as a list of instances each with name, init facts, goal facts. Do not write PDDL.",
                "prompt": "Your name is analyst. Use the public information to build a precise BlocksWorld model. Preserve exactly the allowed actions and constraints. Extract two scenarios named scenario_1 and scenario_2. Include for each scenario: init facts and goal facts expressed with the listed predicates. Do not infer extra objects or facts beyond what is implied. Public information: {environment->public_information}."
            }
        },
        "plan_writer": {
            "propose_plans": {
                "input": [
                    "world_model"
                ],
                "output": "candidate_plans",
                "system_prompt": "You produce executable plans from the normalized world model. Return strict JSON with a list of scenarios, each with name and plan, where plan is an ordered list of actions among: pickup(x), putdown(x), unstack(x,y), stack(x,y). Ensure each step\u2019s preconditions are satisfied by the evolving state. Do not write PDDL.",
                "prompt": "Your name is plan_writer. Using the world model, create legal plans for scenario_1 and scenario_2. For scenario_1, you may start from the user-proposed plan but fix any illegality only if necessary. For scenario_2, construct a valid plan reaching the goal. Output only the JSON structure described in your system instructions. Input world model: {world_model}."
            }
        },
        "auditor": {
            "audit_plans": {
                "input": [
                    "world_model",
                    "candidate_plans"
                ],
                "output": "audited_plans",
                "system_prompt": "You audit temporal and causal correctness of the plans against the world model. Remove bookkeeping shortcuts such as quota tokens or post-hoc penalties; rely only on state transitions from operator preconditions and effects. Return strict JSON with for each scenario: a corrected plan (if needed), a list of causal links (producer -> consumer with supported literal), and a validation summary stating whether the plan achieves the goal. Do not write PDDL.",
                "prompt": "Your name is auditor. Verify that each step in each plan is applicable and that the plan achieves the scenario goal. If a step is illegal or redundant, replace or remove it to yield a minimal correct plan. Provide causal links and a clear validation summary. Inputs: world model: {world_model}; candidate plans: {candidate_plans}."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "world_model",
                    "audited_plans"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You are an expert in classical planning encodings for Fast Downward. Produce a single BlocksWorld PDDL domain and two PDDL problem files, one per scenario, enclosed as: <domain>...</domain><problem name=\"scenario_1\">...</problem><problem name=\"scenario_2\">...</problem>. The domain must include :requirements :strips :typing (optional typing for blocks) and the canonical operators: pick-up, put-down, unstack, stack with predicates: (on ?x ?y), (ontable ?x), (clear ?x), (holding ?x), (handempty). Ensure preconditions and effects match the constraints: pick-up requires ontable, clear, handempty; unstack requires on, clear, handempty; put-down requires holding; stack requires holding and clear(support). After put-down or stack, handempty becomes true; after stack, the support block is not clear; while holding a block, that block is not clear; after stack, the placed block is clear. For each problem, declare exactly the four blocks from the world model as objects, set the initial facts and goal facts from the audited world model, and ensure the problems are solvable by Fast Downward without requiring any custom features. Do not include solver commands.",
                "prompt": "Your name is orchestrator. Integrate the audited world model and plans to produce a final PDDL domain and two problems for Fast Downward. Keep action names and predicates consistent. Use object names from the world model. Return the PDDL wrapped in the required tags only. Inputs: world model: {world_model}; audited plans: {audited_plans}."
            }
        },
        "constraints": [
            "analyst.analyze_spec->plan_writer.propose_plans",
            "analyst.analyze_spec->auditor.audit_plans",
            "plan_writer.propose_plans->auditor.audit_plans",
            "auditor.audit_plans->orchestrator.pddl",
            "analyst.analyze_spec->orchestrator.pddl"
        ]
    }
}