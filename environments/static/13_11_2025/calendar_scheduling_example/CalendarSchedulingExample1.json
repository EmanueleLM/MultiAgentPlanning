{
    "name": "CalendarSchedulingExample1",
    "author": "Human",
    "agents": {
        "number": 5,
        "names": [
            "raymond",
            "billy",
            "donald",
            "auditor",
            "orchestrator"
        ],
        "raymond": {
            "private_information": [
                "Busy Monday: 09:00-09:30, 11:30-12:00, 13:00-13:30, 15:00-15:30"
            ],
            "goal": "List all 30-minute free slots within 09:00-17:00 on Monday that fit my calendar."
        },
        "billy": {
            "private_information": [
                "Busy Monday: 10:00-10:30, 12:00-13:00, 16:30-17:00",
                "Preference: avoid meetings after 15:00 on Monday"
            ],
            "goal": "List all 30-minute free slots within 09:00-17:00 on Monday that fit my calendar and indicate preference-compliant slots."
        },
        "donald": {
            "private_information": [
                "Busy Monday: 09:00-09:30, 10:00-11:00, 12:00-13:00, 14:00-14:30, 16:00-17:00"
            ],
            "goal": "List all 30-minute free slots within 09:00-17:00 on Monday that fit my calendar."
        },
        "auditor": {
            "private_information": [
                "You audit temporal and causal consistency across agents.",
                "You ensure 30-minute contiguous slots, within 09:00-17:00 Monday.",
                "You remove bookkeeping shortcuts or unsupported assumptions and normalize slot format to HH:MM-HH:MM with zero-padded 24h time."
            ],
            "goal": "Produce the intersection of free slots for all participants and mark which slots respect stated preferences."
        },
        "orchestrator": {
            "private_information": [
                "Integrate participant availabilities and auditing results to finalize a meeting time.",
                "Produce a PDDL domain and problem for FastDownward that selects one feasible slot, favoring the earliest preference-compliant time."
            ],
            "goal": "Coordinate agents to schedule a 30-minute meeting for Raymond, Billy, and Donald on Monday within 09:00-17:00."
        }
    },
    "environment": {
        "init": {
            "day": "Monday",
            "work_hours": "09:00-17:00",
            "meeting_duration_minutes": 30,
            "time_unit_minutes": 30,
            "timezone": "local",
            "solver": "FastDownward"
        },
        "public_information": [
            "Participants: Raymond, Billy, Donald.",
            "Meeting duration: 30 minutes.",
            "Work hours to consider: Monday 09:00-17:00.",
            "Billy prefers to avoid meetings after 15:00 on Monday.",
            "Assume calendars listed in private information are accurate.",
            "There exists a feasible meeting time that satisfies all constraints."
        ]
    },
    "workflow": {
        "raymond": {
            "analyze_calendar": {
                "input": [],
                "output": "raymond_slots",
                "system_prompt": "You analyze a single participant calendar. Extract 30-minute free slots within the public work hours and return them in the requested output format; do not emit PDDL.",
                "prompt": "Your name is raymond. Use the public information {environment->public_information} and your private information {agents->raymond->private_information}. Output an object with keys: participant (Raymond), free_slots (array of HH:MM-HH:MM)."
            }
        },
        "billy": {
            "analyze_calendar": {
                "input": [],
                "output": "billy_slots",
                "system_prompt": "You analyze a single participant calendar with preferences. Extract 30-minute free slots within the public work hours and mark preference_compliant true if the slot ends at or before 15:00; do not emit PDDL.",
                "prompt": "Your name is billy. Use the public information {environment->public_information} and your private information {agents->billy->private_information}. Output an object with keys: participant (Billy), free_slots (array of HH:MM-HH:MM), preference_function (explain the rule), preference_compliant_slots (subset of free slots)."
            }
        },
        "donald": {
            "analyze_calendar": {
                "input": [],
                "output": "donald_slots",
                "system_prompt": "You analyze a single participant calendar. Extract 30-minute free slots within the public work hours and return them in the requested output format; do not emit PDDL.",
                "prompt": "Your name is donald. Use the public information {environment->public_information} and your private information {agents->donald->private_information}. Output an object with keys: participant (Donald), free_slots (array of HH:MM-HH:MM)."
            }
        },
        "auditor": {
            "audit_consistency": {
                "input": [
                    "raymond_slots",
                    "billy_slots",
                    "donald_slots"
                ],
                "output": "audited_slots",
                "system_prompt": "You audit temporal and causal consistency across multiple calendars. Normalize all times to HH:MM-HH:MM 24h, ensure each slot is exactly 30 minutes within Monday 09:00-17:00, compute the intersection of free slots across all participants, mark which intersecting slots satisfy Billy's preferences, and reject any slot using shortcuts or unstated assumptions. Do not emit PDDL.",
                "prompt": "Aggregate and audit the inputs. Output an object with keys: intersection_slots (array of HH:MM-HH:MM), preference_compliant (subset of intersection slots), rationale (brief)."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "audited_slots"
                ],
                "output": "pddl_schedule",
                "system_prompt": "You are an expert with PDDL for classical planning targeting the FastDownward solver. Produce a minimal STRIPS domain and problem that select exactly one meeting slot from the audited feasible slots, preferring the earliest preference-compliant slot. Always enclose the domain in <domain></domain> and the problem in <problem></problem>. Keep to :requirements :strips and ensure the plan is a short sequence of grounded actions.",
                "prompt": "Coordinate the final decision for Raymond, Billy, and Donald based on {audited_slots}. Construct a domain with a single action choose_slot(?s) that is applicable only for available(?s) and, if earliest_preferred(?s) exists, ensures the solver can select it. Provide objects for each candidate slot, predicates available(?s) and chosen(?s), and a unary predicate earliest_preferred(?s) set only for the earliest preference-compliant slot. The initial state should mark available for all intersection slots and mark earliest_preferred for the earliest slot that satisfies Billy's preference (if any). The goal is to have some slot chosen; encode selection by making choose_slot add chosen(?s) and delete available(?s). Include a comment indicating the human-readable slot label. Target FastDownward by keeping everything STRIPS-compliant."
            }
        },
        "constraints": [
            "raymond.analyze_calendar->auditor.audit_consistency",
            "billy.analyze_calendar->auditor.audit_consistency",
            "donald.analyze_calendar->auditor.audit_consistency",
            "auditor.audit_consistency->orchestrator.pddl"
        ]
    }
}