{
    "name": "CalendarSchedulingExample15",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "calendar_extractor",
            "scheduler",
            "auditor",
            "orchestrator"
        ],
        "calendar_extractor": {
            "private_information": [
                "Use 30-minute slots aligned to HH:00 and HH:30.",
                "Treat intervals as closed-open [start, end) to avoid boundary ambiguity.",
                "Normalize all times to the specified work window and day."
            ],
            "goal": "Extract, normalize, and summarize each participant's busy and free slots for the specified day and work window."
        },
        "scheduler": {
            "private_information": [
                "Prefer the earliest feasible time that satisfies all constraints.",
                "When multiple options exist, choose the one minimizing fragmentation and respecting participant preferences."
            ],
            "goal": "Propose feasible 30-minute meeting candidates that satisfy all participants' constraints and the meeting duration."
        },
        "auditor": {
            "private_information": [
                "Reject any reasoning reliant on bookkeeping shortcuts (quota tokens, post-hoc penalties, artificial costs).",
                "Verify strict temporal consistency, slot alignment, and absence of conflicts for all participants."
            ],
            "goal": "Audit temporal and causal consistency of proposed meeting times and select the strongest consistent candidate with evidence."
        },
        "orchestrator": {
            "private_information": [
                "Target the FastDownward solver; produce STRIPS-compatible PDDL.",
                "Use discrete 30-minute slots as objects; encode availability with facts; goal is to schedule exactly one slot."
            ],
            "goal": "Integrate upstream outputs and produce a final PDDL domain and problem for FastDownward that captures the audited solution."
        }
    },
    "environment": {
        "init": {
            "day": "Monday",
            "work_start": "09:00",
            "work_end": "17:00",
            "slot_minutes": 30,
            "meeting_duration_minutes": 30,
            "participants": [
                "Joyce",
                "Christine",
                "Alexander"
            ],
            "solver": "FastDownward",
            "time_zone": "LocalOfficeTime"
        },
        "public_information": [
            "Task: Schedule a 30-minute meeting on Monday within work hours 09:00-17:00.",
            "Participants: Joyce, Christine, Alexander.",
            "Existing schedules on Monday: Joyce busy 11:00-11:30, 13:30-14:00, 14:30-16:30.",
            "Existing schedules on Monday: Christine has no meetings but cannot meet before 12:00.",
            "Existing schedules on Monday: Alexander busy 09:00-11:00, 12:00-12:30, 13:30-15:00, 15:30-16:00, 16:30-17:00.",
            "Preference: Choose the earliest feasible time that satisfies everyone.",
            "Time granularity: 30-minute slots, aligned to HH:00 and HH:30.",
            "A feasible solution exists that respects all constraints."
        ]
    },
    "workflow": {
        "calendar_extractor": {
            "normalize_calendars": {
                "input": [],
                "output": "participant_calendars",
                "system_prompt": "You extract and normalize calendars into a canonical JSON structure using the specified day and work window with 30-minute slots. Respect all constraints and participant-specific rules. Do not emit PDDL or plans.",
                "prompt": "You are calendar_extractor. Public information: {environment->public_information}. Initialization: {environment->init}. Your knowledge: {agents->calendar_extractor->private_information}. Produce a normalized summary listing, for each participant, their busy intervals and free 30-minute slots within the work window while honoring constraints such as not-before times. Output concise JSON with keys: participants, busy_by_participant, free_slots_by_participant. Do not propose a meeting and do not emit PDDL."
            }
        },
        "scheduler": {
            "synthesize_candidates": {
                "input": [
                    "participant_calendars"
                ],
                "output": "candidate_slots",
                "system_prompt": "You synthesize feasible meeting candidates from normalized free slots and task constraints. Prefer earliest feasible time and ensure each candidate satisfies all participants' availability and the meeting duration. Do not emit PDDL.",
                "prompt": "You are scheduler. Here is the normalized calendar data: {participant_calendars}. Initialization: {environment->init}. Your knowledge: {agents->scheduler->private_information}. Propose at least three feasible 30-minute candidate slots, sorted by earliest start, that satisfy everyone and the not-before constraint for Christine. Provide a short justification for each candidate and clearly mark the current best candidate. Output JSON with keys: candidates, best_candidate, rationale."
            }
        },
        "auditor": {
            "consistency_audit": {
                "input": [
                    "participant_calendars",
                    "candidate_slots"
                ],
                "output": "audited_selection",
                "system_prompt": "You audit temporal and causal consistency without relying on bookkeeping shortcuts. Verify candidates align to 30-minute boundaries, fall within the work window, and do not overlap any busy interval for any participant. Remove any inconsistent options and select exactly one strongest candidate with brief evidence. Do not emit PDDL.",
                "prompt": "You are auditor. Inputs: normalized calendars {participant_calendars} and proposed candidates {candidate_slots}. Your knowledge: {agents->auditor->private_information}. Audit each candidate for strict consistency and remove any that violate the constraints or depend on artificial penalties. Choose one final slot and provide minimal evidence per participant. Output JSON with keys: selected_slot, evidence."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "participant_calendars",
                    "audited_selection"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You are an expert with multi-agent PDDL problems targeting the FastDownward solver. Produce a PDDL domain and problem that encode 30-minute discrete slots on Monday within the given work window. Use STRIPS-compatible constructs and object types for participants and slots. Encode availability via facts (available ?p ?s) and ensure the goal captures scheduling exactly one slot consistent with the audited selection. Enclose the PDDL domain between <domain></domain> and the PDDL problem between <problem></problem> tags.",
                "prompt": "Integrate the normalized calendars {participant_calendars} and the audited selection {audited_selection}. Use participants and 30-minute slots as objects. Represent availability as facts in the problem. Provide a domain with predicates such as (slot ?s), (participant ?p), (available ?p ?s), (scheduled ?s), and a single action to schedule a slot that requires all participants to be available for that slot. Set the goal to have (scheduled S) for the audited selected slot. Ensure the PDDL is suitable for FastDownward and keep the content self-contained. Output only the PDDL enclosed within the required tags."
            }
        },
        "constraints": [
            "calendar_extractor.normalize_calendars->scheduler.synthesize_candidates",
            "calendar_extractor.normalize_calendars->auditor.consistency_audit",
            "scheduler.synthesize_candidates->auditor.consistency_audit",
            "calendar_extractor.normalize_calendars->orchestrator.pddl",
            "auditor.consistency_audit->orchestrator.pddl"
        ]
    }
}