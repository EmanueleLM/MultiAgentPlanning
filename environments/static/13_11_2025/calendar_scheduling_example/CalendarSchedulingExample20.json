{
    "name": "CalendarSchedulingExample20",
    "author": "Human",
    "agents": {
        "number": 5,
        "names": [
            "ralph_agent",
            "peter_agent",
            "daniel_agent",
            "auditor",
            "orchestrator"
        ],
        "ralph_agent": {
            "private_information": [
                "I represent Ralph.",
                "Busy on Monday: 13:30-14:00; 14:30-15:00."
            ],
            "goal": "Provide accurate availability for a 30-minute meeting on Monday between 09:00 and 17:00."
        },
        "peter_agent": {
            "private_information": [
                "I represent Peter.",
                "Busy on Monday: 09:00-09:30; 11:00-13:00; 16:00-16:30."
            ],
            "goal": "Provide accurate availability for a 30-minute meeting on Monday between 09:00 and 17:00."
        },
        "daniel_agent": {
            "private_information": [
                "I represent Daniel.",
                "Busy on Monday: 09:00-10:00; 10:30-15:30; 16:00-17:00.",
                "Preference: avoid meetings after 13:30 on Monday if possible."
            ],
            "goal": "Provide accurate availability for a 30-minute meeting on Monday between 09:00 and 17:00 while highlighting preferences."
        },
        "auditor": {
            "private_information": [
                "Role: audit temporal/causal consistency and remove bookkeeping shortcuts.",
                "Reject use of quota tokens, post-hoc penalties, or hidden budgets.",
                "Ensure all times align to the same granularity and timezone."
            ],
            "goal": "Validate inputs, compute the intersection of free slots, apply soft preferences, and return a single preferred feasible slot."
        },
        "orchestrator": {
            "private_information": [],
            "goal": "Coordinate agents, integrate audited availability, and produce the final PDDL domain and problem compatible with the Fast Downward planner to pick a single valid meeting time."
        }
    },
    "environment": {
        "init": {
            "day": "Monday",
            "work_start": "09:00",
            "work_end": "17:00",
            "meeting_duration_minutes": 30,
            "slot_granularity_minutes": 30,
            "timezone": "UTC"
        },
        "public_information": [
            "Task: Schedule a 30-minute meeting for Ralph, Peter, and Daniel on Monday within 09:00-17:00 work hours.",
            "All calendar times use 24-hour format and refer to the same timezone.",
            "Daniel prefers to avoid meetings after 13:30 on Monday if possible.",
            "A feasible time exists that respects all constraints."
        ]
    },
    "workflow": {
        "ralph_agent": {
            "availability": {
                "input": [],
                "output": "availability_ralph",
                "system_prompt": "You are a calendar analyst. Using the public work hours and duration together with your private busy times, compute all 30-minute candidate slots within Monday 09:00-17:00 that do not overlap your busy intervals. Return a strict JSON object with keys busy and free where busy is a list of [start,end] strings using HH:MM and free is a list of non-overlapping candidate 30-minute slots within the work window. Do not include explanations.",
                "prompt": "Your name is ralph_agent. Public context: {environment->public_information}. Your private calendar: {agents->ralph_agent->private_information}. Goal: {agents->ralph_agent->goal}. Output only the specified JSON object with keys busy and free."
            }
        },
        "peter_agent": {
            "availability": {
                "input": [],
                "output": "availability_peter",
                "system_prompt": "You are a calendar analyst. Using the public work hours and duration together with your private busy times, compute all 30-minute candidate slots within Monday 09:00-17:00 that do not overlap your busy intervals. Return a strict JSON object with keys busy and free where busy is a list of [start,end] strings using HH:MM and free is a list of non-overlapping candidate 30-minute slots within the work window. Do not include explanations.",
                "prompt": "Your name is peter_agent. Public context: {environment->public_information}. Your private calendar: {agents->peter_agent->private_information}. Goal: {agents->peter_agent->goal}. Output only the specified JSON object with keys busy and free."
            }
        },
        "daniel_agent": {
            "availability": {
                "input": [],
                "output": "availability_daniel",
                "system_prompt": "You are a calendar analyst. Using the public work hours and duration together with your private busy times and preferences, compute all 30-minute candidate slots within Monday 09:00-17:00 that do not overlap your busy intervals. Return a strict JSON object with keys busy, free, and preferences where busy is a list of [start,end] strings using HH:MM, free is a list of non-overlapping candidate 30-minute slots within the work window, and preferences is a short list of applicable soft constraints such as avoiding times after 13:30. Do not include explanations.",
                "prompt": "Your name is daniel_agent. Public context: {environment->public_information}. Your private calendar: {agents->daniel_agent->private_information}. Goal: {agents->daniel_agent->goal}. Output only the specified JSON object with keys busy, free, and preferences."
            }
        },
        "auditor": {
            "audit": {
                "input": [
                    "availability_ralph",
                    "availability_peter",
                    "availability_daniel"
                ],
                "output": "audited_availability",
                "system_prompt": "You audit temporal and causal consistency and remove bookkeeping shortcuts such as quota tokens, post-hoc penalties, or hidden budgets. Validate that all free slots align to the same 30-minute granularity, occur on Monday within 09:00-17:00 UTC, and do not overlap any declared busy intervals. Compute the intersection across all participants to produce common_free. Apply soft preferences by selecting a preferred slot before 13:30 if available; otherwise choose the earliest common slot. Return a strict JSON object with keys common_free (list of [start,end]), preferred (single [start,end]), and rationale (short sentence). Do not output PDDL or additional commentary.",
                "prompt": "Inputs from agents: Ralph: {availability_ralph}; Peter: {availability_peter}; Daniel: {availability_daniel}. Validate consistency, compute common_free, choose preferred respecting Daniel's soft preference if possible, and return only the JSON object with keys common_free, preferred, and rationale."
            }
        },
        "orchestrator": {
            "synthesize_pddl": {
                "input": [
                    "audited_availability"
                ],
                "output": "pddl_schedule",
                "system_prompt": "You are an expert in temporal planning and PDDL targeting the Fast Downward planner. Produce a STRIPS-compatible PDDL domain and problem that model selecting exactly one meeting timeslot from a finite set of discrete 30-minute slots. Represent participants and timeslots as objects. Use predicates such as available ?p ?t, chosen ?t, assigned ?p ?t, preferred ?t, and maybe before ?t1 ?t2 if needed. Provide action schemas that allow choosing one slot t that is available for all participants and then assigning every participant to that slot; ensure no multiple selections occur. The initial state must encode availability for Ralph, Peter, and Daniel and mark a single preferred slot if provided. The goal must ensure that all participants are assigned to exactly one chosen slot. Output exactly two blocks: the PDDL domain enclosed in <domain></domain> and the PDDL problem enclosed in <problem></problem>. Use lowercase, hyphen-free names and simple constructs accepted by Fast Downward.",
                "prompt": "Integrate the audited availability and preference: {audited_availability}. Construct the concrete PDDL domain and problem for the Monday scheduling scenario at 30-minute granularity, defining objects for each common_free slot (for example t1000_1030), participants (ralph peter daniel), and a predicate preferred for the preferred slot if present. Ensure preconditions require that the chosen slot is available for all participants, enforce selection of exactly one slot, and achieve the goal that all participants are assigned. Provide only the two blocks wrapped by <domain></domain> and <problem></problem>."
            }
        },
        "constraints": [
            "ralph_agent.availability->auditor.audit",
            "peter_agent.availability->auditor.audit",
            "daniel_agent.availability->auditor.audit",
            "auditor.audit->orchestrator.synthesize_pddl"
        ]
    }
}