{
    "name": "Depots4",
    "author": "Human",
    "agents": {
        "number": 6,
        "names": [
            "modeler",
            "worldstate",
            "planner",
            "auditor",
            "mapper",
            "orchestrator"
        ],
        "modeler": {
            "private_information": [
                "Expert at extracting STRIPS-like action schemas from natural descriptions",
                "Keeps action names, argument order, and predicate signatures stable"
            ],
            "goal": "Extract consistent action schemas, predicates, and invariants from the public information without emitting PDDL."
        },
        "worldstate": {
            "private_information": [
                "Expert at structuring scenarios (initial states and goals) from narrative statements",
                "Keeps object naming stable (object_0, object_1, ...)"
            ],
            "goal": "Produce clean scenario blocks for each statement, listing init facts and goal facts without emitting PDDL."
        },
        "planner": {
            "private_information": [
                "Proposes action sequences using the extracted action schemas",
                "Does not produce PDDL and does not assume magical bookkeeping tokens"
            ],
            "goal": "Validate the given plan for the first scenario and propose a candidate plan or rationale for the second scenario using only causally supported steps."
        },
        "auditor": {
            "private_information": [
                "Specialized in auditing temporal and causal consistency",
                "Removes bookkeeping shortcuts such as quota tokens and post-hoc penalties",
                "Ensures all preconditions are supported when each step is executed"
            ],
            "goal": "Audit the candidate plans, repair them if needed, and produce a causally valid, temporally consistent plan set with explicit supporting facts and justifications."
        },
        "mapper": {
            "private_information": [
                "Builds the object universe and predicate signatures",
                "Prepares grounding hints and typing suggestions without emitting PDDL"
            ],
            "goal": "Provide the list of objects, predicate signatures with arity (and optional types), and a mapping from narrative facts to predicate forms to ease compilation."
        },
        "orchestrator": {
            "private_information": [
                "Integrates all upstream artifacts",
                "Compiles final PDDL for FastDownward",
                "Verifies that auditor-approved plans map cleanly to the problem"
            ],
            "goal": "Produce the final PDDL domain and problem(s) targeting the FastDownward solver, using the audited plan(s), action schemas, and scenario definitions."
        }
    },
    "environment": {
        "init": {
            "grid_size": 5,
            "visibility": 2,
            "objects": [
                "object_0",
                "object_1",
                "object_2",
                "object_3",
                "object_4",
                "object_5",
                "object_6",
                "object_7",
                "object_8",
                "object_9"
            ],
            "predicate_templates": [
                "cats(x)",
                "hand(x)",
                "sneeze(x)",
                "spring(x)",
                "stupendous(x)",
                "texture(x)",
                "collect(x,y)",
                "vase(x,y)",
                "next(x,y)"
            ]
        },
        "public_information": [
            "Available actions and their argument signatures: paltry(object_0, object_1, object_2), sip(object_0, object_1, object_2), clip(object_0, object_1, object_2), wretched(object_0, object_1, object_2, object_3), memory(object_0, object_1, object_2), tightfisted(object_0, object_1, object_2).",
            "paltry preconditions: hand object_0, cats object_1, texture object_2, vase object_0 object_1, next object_1 object_2. paltry add effects: next object_0 object_2. paltry delete effects: vase object_0 object_1.",
            "sip preconditions: hand object_0, cats object_1, texture object_2, next object_0 object_2, next object_1 object_2. sip add effects: vase object_0 object_1. sip delete effects: next object_0 object_2.",
            "clip preconditions: hand object_0, sneeze object_1, texture object_2, next object_1 object_2, next object_0 object_2. clip add effects: vase object_0 object_1. clip delete effects: next object_0 object_2.",
            "wretched preconditions: sneeze object_0, texture object_1, texture object_2, stupendous object_3, next object_0 object_1, collect object_1 object_3, collect object_2 object_3. wretched add effects: next object_0 object_2. wretched delete effects: next object_0 object_1.",
            "memory preconditions: cats object_0, spring object_1, spring object_2, next object_0 object_1. memory add effects: next object_0 object_2. memory delete effects: next object_0 object_1.",
            "tightfisted preconditions: hand object_0, sneeze object_1, texture object_2, next object_1 object_2, vase object_0 object_1. tightfisted add effects: next object_0 object_2. tightfisted delete effects: vase object_0 object_1.",
            "Statement A initial facts: cats object_0; cats object_1; collect object_6 object_2; collect object_7 object_3; hand object_8; hand object_9; next object_0 object_6; next object_1 object_6; next object_4 object_6; next object_5 object_7; next object_8 object_7; next object_9 object_7; sneeze object_4; sneeze object_5; spring object_6; spring object_7; stupendous object_2; stupendous object_3; texture object_6; texture object_7.",
            "Statement A goal: next object_8 object_7 and next object_9 object_6.",
            "Statement A proposed plan: memory object_1 object_6 object_7; sip object_9 object_1 object_7; memory object_1 object_7 object_6; paltry object_9 object_1 object_6.",
            "Statement B initial facts: cats object_0; collect object_5 object_1; collect object_6 object_1; collect object_7 object_2; collect object_8 object_2; hand object_9; next object_0 object_7; next object_3 object_5; next object_4 object_7; next object_9 object_7; sneeze object_3; sneeze object_4; spring object_5; spring object_7; stupendous object_1; stupendous object_2; texture object_5; texture object_6; texture object_7; texture object_8.",
            "Statement B goal: next object_9 object_8.",
            "General modeling notes: Use STRIPS-style predicates cats(x), hand(x), sneeze(x), spring(x), stupendous(x), texture(x), and binary predicates collect(x,y), vase(x,y), next(x,y). No hidden tokens, quotas, or post-hoc penalties are allowed; all preconditions must be established by prior steps or initial facts."
        ]
    },
    "workflow": {
        "modeler": {
            "extract_actions": {
                "input": [],
                "output": "actions_model",
                "system_prompt": "You extract STRIPS-like action schemas from text, preserving names, argument order, and predicate signatures; do not emit PDDL.",
                "prompt": "Your name is modeler. Use the public information to list action schemas with parameters, preconditions (as positive literals), add effects, and delete effects; also list all predicates with arity and any invariants you can infer. Keep names exactly as given (paltry, sip, clip, wretched, memory, tightfisted; predicates cats, hand, sneeze, spring, stupendous, texture, collect, vase, next). Output a concise, structured description only, no PDDL. Public information: {environment->public_information}."
            }
        },
        "worldstate": {
            "enumerate_states": {
                "input": [],
                "output": "scenarios",
                "system_prompt": "You structure scenario blocks (initial facts and goals) from narrative text; do not emit PDDL.",
                "prompt": "Your name is worldstate. From the public information, produce two scenario blocks: scenario_A and scenario_B. Each must have an objects list (object_0..object_9 if referenced), an init list of ground facts, and a goal list of ground facts. Include the proposed plan for scenario_A as received, and indicate that scenario_B has no given plan. Public information: {environment->public_information}."
            }
        },
        "planner": {
            "propose_plan": {
                "input": [
                    "actions_model",
                    "scenarios"
                ],
                "output": "candidate_plans",
                "system_prompt": "You propose action sequences using the extracted schemas; do not emit PDDL.",
                "prompt": "Your name is planner. Using the action schemas and scenarios, first check whether the given plan for scenario_A is causally supported step by step with required preconditions; if not, repair minimally. Then propose a candidate plan for scenario_B (or explain why none exists) using only available preconditions and effects, avoiding any bookkeeping shortcuts. Keep action names as given and arguments as object_i constants."
            }
        },
        "auditor": {
            "audit_consistency": {
                "input": [
                    "actions_model",
                    "candidate_plans"
                ],
                "output": "audited_plans",
                "system_prompt": "You audit temporal and causal consistency, removing bookkeeping shortcuts and ensuring every precondition is supported; do not emit PDDL.",
                "prompt": "Your name is auditor. Audit the candidate plans. For each scenario, verify each step's preconditions are satisfied at execution time, show the supporting facts, and provide a corrected minimal plan if needed. If a goal is unreachable under the given actions, provide a precise diagnosis. Produce: audited_plan_A, audited_plan_B, and a summary of causal links and threats resolved."
            }
        },
        "mapper": {
            "object_map": {
                "input": [
                    "scenarios",
                    "actions_model"
                ],
                "output": "pddl_grounding",
                "system_prompt": "You map narrative to a PDDL-ready grounding set without emitting PDDL.",
                "prompt": "Your name is mapper. Provide 1) the object universe used across scenarios (constants object_0..object_9 where needed), 2) predicate signatures with arity (and optional simple types like thing), and 3) a normalized mapping format for all ground facts present in the scenarios. This is a preparatory grounding guide; do not emit PDDL."
            }
        },
        "orchestrator": {
            "compile_pddl": {
                "input": [
                    "actions_model",
                    "scenarios",
                    "pddl_grounding",
                    "audited_plans"
                ],
                "output": "fd_pddl",
                "system_prompt": "You are an expert with PDDL for FastDownward. Produce a PDDL domain and problem files compatible with FastDownward (:requirements at least :strips :negative-preconditions and optionally :typing). You must enclose the PDDL domain between <domain></domain> tags and each PDDL problem between <problem></problem> tags.",
                "prompt": "Integrate the extracted action schemas, audited plans, and grounding guide to compile a clean PDDL domain and two problems (scenario_A and scenario_B). Use stable predicate and action names exactly as given. Include all necessary objects and only ground initial facts that are stated. For each problem, set the goal as specified for that scenario. Ensure FastDownward compatibility and avoid extraneous features. If a scenario is provably unsolvable under the given actions, still provide the problem with the stated goal. Output one <domain> block followed by two <problem> blocks, one per scenario."
            }
        },
        "constraints": [
            "modeler.extract_actions->planner.propose_plan",
            "worldstate.enumerate_states->planner.propose_plan",
            "planner.propose_plan->auditor.audit_consistency",
            "modeler.extract_actions->auditor.audit_consistency",
            "worldstate.enumerate_states->mapper.object_map",
            "modeler.extract_actions->mapper.object_map",
            "mapper.object_map->orchestrator.compile_pddl",
            "worldstate.enumerate_states->orchestrator.compile_pddl",
            "auditor.audit_consistency->orchestrator.compile_pddl"
        ]
    }
}