{
    "name": "MeetingPlanningExample3",
    "author": "Human",
    "agents": {
        "number": 4,
        "names": [
            "traveler",
            "schedule_explorer",
            "temporal_auditor",
            "orchestrator"
        ],
        "traveler": {
            "private_information": [
                "I value meeting friends over idle time.",
                "I arrive at Bayview at 09:00.",
                "I am flexible on departure/return times within the same day."
            ],
            "goal": "Meet as many friends as possible today while ensuring at least 90 minutes with Barbara within her availability window."
        },
        "schedule_explorer": {
            "private_information": [
                "I enumerate multiple feasible schedules using provided travel times and time windows.",
                "I consider alternative departure and return times to trade off meeting duration vs. travel."
            ],
            "goal": "Generate several candidate schedules that respect the constraints and aim to maximize friend meetings, including a plan that guarantees at least 90 minutes with Barbara."
        },
        "temporal_auditor": {
            "private_information": [
                "I rigorously check temporal and causal consistency of schedules.",
                "I reject bookkeeping shortcuts such as negative time, zero-duration travel, quota tokens, or post-hoc penalties.",
                "I verify minimum meeting durations and availability windows."
            ],
            "goal": "Audit candidate schedules for feasibility, remove invalid ones, annotate remaining with reasons and scores, and ensure no shortcutting of time or resources."
        },
        "orchestrator": {
            "private_information": [],
            "goal": "Coordinate the agents' outputs, pick the best audited schedule according to the objectives, and produce a final PDDL domain and problem (compatible with FastDownward) to achieve that schedule."
        }
    },
    "environment": {
        "init": {
            "time_unit": "minutes",
            "time_format": "HH:MM",
            "locations": [
                "Bayview",
                "Golden Gate Park"
            ],
            "start_location": "Bayview",
            "start_time": "09:00",
            "friends": [
                {
                    "name": "Barbara",
                    "location": "Golden Gate Park",
                    "available_from": "08:00",
                    "available_to": "11:30",
                    "min_meeting_minutes": 90
                }
            ],
            "travel": {
                "Bayview->Golden Gate Park": 22,
                "Golden Gate Park->Bayview": 23
            }
        },
        "public_information": [
            "Travel time Bayview to Golden Gate Park: 22 minutes.",
            "Travel time Golden Gate Park to Bayview: 23 minutes.",
            "Arrival at Bayview: 09:00.",
            "Barbara is at Golden Gate Park from 08:00 to 11:30.",
            "You would like to meet Barbara for a minimum of 90 minutes.",
            "Objective: meet as many friends as possible today; with the known data, prioritize satisfying Barbara's constraint and maximizing total quality time."
        ]
    },
    "workflow": {
        "traveler": {
            "preferences": {
                "input": [],
                "output": "user_prefs",
                "system_prompt": "You are the traveler. Summarize hard constraints and preferences as a compact JSON object without inventing new facts. Do not produce PDDL.",
                "prompt": "Your name is traveler. Public information: {environment->public_information}. Your knowledge: {agents->traveler->private_information}. Goal: {agents->traveler->goal}. Provide a JSON object with fields: start_location, start_time, required_meetings (with person, location, min_minutes), optimization (priority order), and any soft preferences. Keep it factual and concise."
            }
        },
        "schedule_explorer": {
            "enumerate_schedules": {
                "input": [
                    "user_prefs"
                ],
                "output": "candidate_schedules",
                "system_prompt": "You enumerate feasible day schedules using travel times and time windows. Produce multiple alternatives with timestamps and actions. Do not produce PDDL.",
                "prompt": "Your name is schedule_explorer. Public information: {environment->public_information}. Use user preferences: {user_prefs}. Enumerate several candidate schedules in JSON array form. For each schedule, provide a list of steps with fields: at_time (HH:MM), action (move, meet, wait), from, to, duration_minutes, person (if meeting), and location. Ensure meeting with Barbara is at Golden Gate Park and consider departures such as 09:00, 09:10, 09:20, etc., to explore trade-offs. Include computed arrival times using travel durations. Include a summary for each schedule: total_meeting_minutes, meets_required_constraints (boolean), notes."
            }
        },
        "temporal_auditor": {
            "audit": {
                "input": [
                    "candidate_schedules"
                ],
                "output": "audited_schedules",
                "system_prompt": "You audit temporal and causal consistency. Reject any schedule with time arithmetic errors, overlapping actions for the same agent, or violations of availability windows and minimum meeting durations. Remove bookkeeping shortcuts like zero-time travel or retroactive adjustments. Do not produce PDDL.",
                "prompt": "Your name is temporal_auditor. Audit the candidate schedules: {candidate_schedules}. Check that travel uses exact durations (22 minutes Bayview->Golden Gate Park; 23 minutes Golden Gate Park->Bayview), that meetings occur within availability windows, and that the Barbara meeting lasts at least 90 minutes. Remove invalid schedules. For valid ones, annotate with fields: feasibility (boolean), violations (empty if feasible), objective_score (prioritize meeting count, then meeting minutes, then less travel), and rationale. Output a JSON object with fields: valid_schedules (array) and rejected (array with reasons)."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "audited_schedules"
                ],
                "output": "pddl_fd",
                "system_prompt": "You are an expert in PDDL for the FastDownward solver. From audited schedules, choose the best one and produce a classical PDDL domain and problem that a FastDownward STRIPS-compatible configuration can solve. Use discrete minutes if needed. Keep actions distinct: move, wait, meet. Encode time progression as a sequence of minute ticks or cumulative time index and enforce availability and minimum meeting duration via predicates and goals. Enclose the PDDL domain in <domain></domain> and the PDDL problem in <problem></problem>.",
                "prompt": "You are orchestrator. Use the audited schedules: {audited_schedules}. Select the top-scoring feasible schedule. Synthesize a PDDL domain and problem compatible with FastDownward that achieves the chosen schedule from the initial state. Model: locations {Bayview, GoldenGatePark}, person barbara, minutes discretized as needed. Predicates may include at(agent, location, time_index), next(time_i, time_j), met(barbara), met90(barbara). Actions: move_Bayview_to_GGP (cost 22 via time progression), move_GGP_to_Bayview (cost 23), wait_1min, meet_barbara_1min (only valid at GoldenGatePark within 08:00-11:30 window). The goal must ensure at least 90 minutes of meet_barbara_1min within the window. Provide <domain> and <problem> tags only."
            }
        },
        "constraints": [
            "traveler.preferences->schedule_explorer.enumerate_schedules",
            "schedule_explorer.enumerate_schedules->temporal_auditor.audit",
            "temporal_auditor.audit->orchestrator.pddl"
        ]
    }
}