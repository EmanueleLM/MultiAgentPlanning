{
    "name": "MysteryBlocksworld18",
    "author": "Human",
    "agents": {
        "number": 5,
        "names": [
            "modeler",
            "grounder",
            "validator",
            "auditor",
            "orchestrator"
        ],
        "modeler": {
            "private_information": [
                "I specialize in converting natural-language operator descriptions into a lifted, machine-readable action model.",
                "I do not emit PDDL; I provide a clean JSON schema of predicates and actions with preconditions and effects."
            ],
            "goal": "Extract a lifted action model and predicate set from the public description so other agents can ground, validate, and solve the planning tasks."
        },
        "grounder": {
            "private_information": [
                "I ground lifted operators over enumerated objects for specific scenarios and assemble problem instances.",
                "I do not emit PDDL; I output JSON problems with objects, init, and goals for each scenario."
            ],
            "goal": "Produce grounded problem instances for Scenario A and Scenario B using the lifted model and the public initial states and goals."
        },
        "validator": {
            "private_information": [
                "I simulate plans step-by-step to check preconditions, apply effects, and confirm goal satisfaction.",
                "I do not emit PDDL; I return an explicit trace and diagnostics in JSON."
            ],
            "goal": "Validate the provided plan for Scenario A against the grounded instance and report any causal flaws or violations."
        },
        "auditor": {
            "private_information": [
                "I audit temporal and causal consistency, looking for unsupported effects, missing preconditions, and shortcut devices such as quota tokens or post-hoc penalties.",
                "I normalize naming and remove bookkeeping shortcuts, ensuring that actions are justified strictly by declared preconditions and effects."
            ],
            "goal": "Audit the model, grounded problems, and validated plan to ensure consistency, eliminate bookkeeping shortcuts, and provide a clear report for orchestration."
        },
        "orchestrator": {
            "private_information": [
                "I integrate contributions from other agents and produce the final artifacts.",
                "I emit the final PDDL domain and problem compatible with the Fast Downward planner."
            ],
            "goal": "Generate a correct PDDL domain and a PDDL problem targeting Fast Downward for Scenario B, ensuring that the model aligns with the audited specification."
        }
    },
    "environment": {
        "init": {
            "objects": [
                "object_0",
                "object_1",
                "object_2",
                "object_3",
                "object_4",
                "object_5",
                "object_6",
                "object_7",
                "object_8",
                "object_9",
                "object_10",
                "object_11",
                "object_12",
                "object_13"
            ],
            "notes": "Objects are untyped by default; all predicates are binary or unary as written in the public information."
        },
        "public_information": [
            "Action descriptions available to all agents:",
            "paltry(x0, x1, x2) requires hand x0, cats x1, texture x2, vase x0 x1, and next x1 x2; it adds next x0 x2 and deletes vase x0 x1.",
            "sip(x0, x1, x2) requires hand x0, cats x1, texture x2, next x0 x2, and next x1 x2; it adds vase x0 x1 and deletes next x0 x2.",
            "clip(x0, x1, x2) requires hand x0, sneeze x1, texture x2, next x1 x2, and next x0 x2; it adds vase x0 x1 and deletes next x0 x2.",
            "wretched(x0, x1, x2, x3) requires sneeze x0, texture x1, texture x2, stupendous x3, next x0 x1, collect x1 x3, and collect x2 x3; it adds next x0 x2 and deletes next x0 x1.",
            "memory(x0, x1, x2) requires cats x0, spring x1, spring x2, and next x0 x1; it adds next x0 x2 and deletes next x0 x1.",
            "tightfisted(x0, x1, x2) requires hand x0, sneeze x1, texture x2, next x1 x2, and vase x0 x1; it adds next x0 x2 and deletes vase x0 x1.",
            "Scenario A initial facts: cats object_0, cats object_1, collect object_6 object_2, collect object_7 object_2, collect object_8 object_3, collect object_9 object_3, hand object_10, hand object_11, hand object_12, hand object_13, next object_0 object_8, next object_1 object_8, next object_10 object_7, next object_11 object_9, next object_12 object_8, next object_13 object_9, next object_4 object_7, next object_5 object_9, sneeze object_4, sneeze object_5, spring object_6, spring object_8, stupendous object_2, stupendous object_3, texture object_6, texture object_7, texture object_8 and texture object_9.",
            "Scenario A goal: next object_10 object_6, next object_11 object_8, next object_12 object_7 and next object_13 object_9.",
            "Scenario A proposed plan sequence: clip object_11 object_5 object_9; wretched object_5 object_9 object_8 object_3; tightfisted object_11 object_5 object_8; clip object_10 object_4 object_7; sip object_12 object_1 object_8; memory object_1 object_8 object_6; paltry object_12 object_1 object_6; wretched object_4 object_7 object_6 object_2; clip object_12 object_4 object_6; tightfisted object_10 object_4 object_6; wretched object_4 object_6 object_7 object_2; tightfisted object_12 object_4 object_7.",
            "Scenario B initial facts: cats object_0, collect object_10 object_2, collect object_5 object_1, collect object_6 object_1, collect object_7 object_1, collect object_8 object_2, collect object_9 object_2, hand object_11, next object_0 object_8, next object_11 object_6, next object_3 object_7, next object_4 object_8, sneeze object_3, sneeze object_4, spring object_5, spring object_8, stupendous object_1, stupendous object_2, texture object_10, texture object_5, texture object_6, texture object_7, texture object_8 and texture object_9.",
            "Scenario B goal: next object_11 object_10.",
            "Scenario B plan: no plan provided."
        ]
    },
    "workflow": {
        "modeler": {
            "extract": {
                "input": [],
                "output": "lifted_model",
                "system_prompt": "You convert the public description into a lifted planning model without emitting PDDL. Return compact JSON with keys: predicates (list of predicate signatures like [name, arity]), actions (map from action name to {parameters: [x0, x1, ...], pre: [atoms], add: [atoms], del: [atoms]}). Atoms should be strings using the same symbol names as in public information, with variables like x0, x1, etc.",
                "prompt": "Your name is modeler. From the public information, extract the lifted action schemas paltry, sip, clip, wretched, memory, and tightfisted, and the set of predicate symbols used (cats, hand, sneeze, spring, stupendous, texture, collect, vase, next). Do not invent predicates or change arities. Output a single JSON object for lifted_model as specified by your system prompt."
            }
        },
        "grounder": {
            "ground": {
                "input": [
                    "lifted_model"
                ],
                "output": "grounded_problems",
                "system_prompt": "You produce grounded problem data for scenarios without emitting PDDL. Return JSON with keys: scenarioA and scenarioB. Each scenario contains: objects (list of object names), init (list of ground atoms as strings), goal (list of ground atoms as strings). Use exactly the objects and facts stated in public information; do not infer additional facts.",
                "prompt": "Your name is grounder. Use the public Scenario A and Scenario B descriptions to build grounded instances. For both scenarios, include all objects from environment.init.objects. For init and goal, copy the listed facts exactly as written. Do not add or remove any fact. Return a single JSON object for grounded_problems as specified by your system prompt."
            }
        },
        "validator": {
            "check_plan": {
                "input": [
                    "lifted_model",
                    "grounded_problems"
                ],
                "output": "validated_plan_A",
                "system_prompt": "You validate a plan by forward simulation over a STRIPS-like model. Return JSON with keys: valid (boolean), reached_goal (boolean), first_failure (null or {step_index, action, unmet_preconditions}), trace (list of {step, action, pre_checked: true/false, applied: true/false, state_delta: {add: [...], del: [...]}}). Do not emit PDDL.",
                "prompt": "Your name is validator. Validate the proposed plan for Scenario A exactly in the order provided in the public information. Use the lifted_model and grounded_problems.scenarioA. Check preconditions at each step; if any are not satisfied, record first_failure and stop applying further actions. If all steps apply, set valid true and report whether the goal is achieved. Return a single JSON object for validated_plan_A as specified by your system prompt."
            }
        },
        "auditor": {
            "audit": {
                "input": [
                    "lifted_model",
                    "grounded_problems",
                    "validated_plan_A"
                ],
                "output": "consistency_report",
                "system_prompt": "You audit temporal and causal consistency and eliminate bookkeeping shortcuts such as quota tokens, post-hoc penalties, or magic effects. Return JSON with keys: findings (list of strings), naming_normalization (map if any changes are required), model_issues (list of detected inconsistencies), recommended_fixes (list of concrete changes to preconditions/effects if needed), cleaned_model (optional lifted model if edits are required, otherwise null). Do not emit PDDL.",
                "prompt": "Your name is auditor. Review the lifted_model, Scenario A and B grounded problems, and the validator's trace. Ensure that every effect is causally supported by declared preconditions, that deletions match the model, and that no extra-bookkeeping devices are needed. If the plan for Scenario A fails, explain precisely which preconditions are missing and whether they reflect an issue in the plan or the model. Provide a concise consistency_report as specified by your system prompt."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "lifted_model",
                    "grounded_problems",
                    "consistency_report"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You are an expert with multi-agent PDDL problems. You must produce a PDDL domain and a PDDL problem that are directly consumable by the Fast Downward planner (for example: fast-downward.py --alias lama-first domain.pddl problem.pddl). Use STRIPS-style operators with only positive preconditions, add and delete lists; avoid durative actions, quantifiers, or conditional effects. Enclose the PDDL domain between <domain></domain> and the PDDL problem between <problem></problem> tags.",
                "prompt": "Integrate the lifted_model and the grounded_problems, respecting any adjustments noted in the consistency_report, to produce a final PDDL domain and a PDDL problem for Scenario B with the goal next object_11 object_10. Keep predicate and object names exactly as in public information (use hyphen-free, lowercase symbols). Include all six actions paltry, sip, clip, wretched, memory, tightfisted with the precise preconditions and effects stated. The problem should include all objects from environment.init.objects, the exact initial facts from Scenario B, and the specified goal. Produce only the two tagged blocks: <domain>...</domain> and <problem>...</problem>."
            }
        },
        "constraints": [
            "modeler.extract->grounder.ground",
            "modeler.extract->validator.check_plan",
            "grounder.ground->validator.check_plan",
            "modeler.extract->auditor.audit",
            "grounder.ground->auditor.audit",
            "validator.check_plan->auditor.audit",
            "auditor.audit->orchestrator.pddl",
            "grounder.ground->orchestrator.pddl",
            "modeler.extract->orchestrator.pddl"
        ]
    }
}