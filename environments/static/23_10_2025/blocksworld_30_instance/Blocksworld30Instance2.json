{
    "name": "Blocksworld30Instance2",
    "author": "Human",
    "agents": {
        "number": 3,
        "names": [
            "agent1",
            "agent2",
            "orchestrator"
        ],
        "agent1": {
            "private_information": [
                "I am one of two manipulators acting on the blocks sequentially.",
                "I can pick up, put down, unstack and stack blocks following Blocks World constraints (only top block can be moved, carry one block at a time)."
            ],
            "goal": "Observe the initial configuration and the given action sequence, simulate the moves applicable to the information I have, and report the state transitions I perceive."
        },
        "agent2": {
            "private_information": [
                "I am the second manipulator acting in the same Blocks World environment.",
                "I can pick up, put down, unstack and stack blocks following Blocks World constraints (only top block can be moved, carry one block at a time)."
            ],
            "goal": "Observe the initial configuration and the given action sequence, simulate the moves applicable to the information I have, and report the state transitions I perceive."
        },
        "orchestrator": {
            "private_information": [
                "I coordinate and integrate observations from both agents and produce the final planning artifacts."
            ],
            "goal": "Integrate agent observations and produce a PDDL domain and PDDL problem encoding the final arrangement of blocks, formatted for the FastDownwards solver."
        }
    },
    "environment": {
        "init": {
            "grid_size": 4,
            "visibility": 1
        },
        "public_information": [
            "There are ten blocks labeled A, B, C, D, E, F, G, H, I, J.",
            "Blocks world rules: only the top block of a stack can be moved; an agent can carry at most one block at a time; blocks can be stacked on another block or put down on the table.",
            "Initial arrangement (each statement describes which block is directly on what): A on J, B on table, C on table, D on C, E on B, F on I, G on F, H on D, I on H, J on E.",
            "The agents execute the following actions in this exact order: 1. unstack(G, F) 2. putdown(G) 3. unstack(A, J) 4. stack(A, G) 5. unstack(J, E) 6. stack(J, A) 7. unstack(E, B) 8. stack(E, F) 9. unstack(J, A) 10. stack(J, E) 11. unstack(A, G) 12. stack(A, G) 13. pickup(B) 14. putdown(B) 15. unstack(J, E) 16. putdown(J) 17. pickup(B) 18. stack(B, A) 19. unstack(B, A) 20. stack(B, J) 21. unstack(A, G) 22. stack(A, E) 23. pickup(G) 24. putdown(G) 25. unstack(A, E) 26. stack(A, G) 27. unstack(E, F) 28. stack(E, F) 29. unstack(A, G) 30. stack(A, E)."
        ]
    },
    "workflow": {
        "agent1": {
            "observe": {
                "input": [],
                "output": "observe_agent1",
                "system_prompt": "You are agent1 in a Blocks World environment. Based on the public information and your private capabilities, simulate the provided ordered action sequence where you are responsible for applying actions when it is your turn. Do not produce PDDL. Provide a clear, stepwise account of each state change you observe or perform, and produce your final observed configuration as a list of direct on/ontable facts.",
                "prompt": "Your name is agent1. Public information: {environment->public_information}. Your private information: {agents->agent1->private_information}. Your goal: {agents->agent1->goal}. Think step by step and produce the state transitions you observe and a final list of relations of the form on(X,Y) or ontable(X). If you cannot simulate an action because preconditions are not met, note it explicitly."
            }
        },
        "agent2": {
            "observe": {
                "input": [],
                "output": "observe_agent2",
                "system_prompt": "You are agent2 in a Blocks World environment. Based on the public information and your private capabilities, simulate the provided ordered action sequence where you may perform some of the listed moves. Do not produce PDDL. Provide a clear, stepwise account of each state change you observe or perform, and produce your final observed configuration as a list of direct on/ontable facts.",
                "prompt": "Your name is agent2. Public information: {environment->public_information}. Your private information: {agents->agent2->private_information}. Your goal: {agents->agent2->goal}. Think step by step and produce the state transitions you observe and a final list of relations of the form on(X,Y) or ontable(X). If you cannot simulate an action because preconditions are not met, note it explicitly."
            }
        },
        "orchestrator": {
            "pddl": {
                "input": [
                    "observe_agent1",
                    "observe_agent2"
                ],
                "output": "pddl_orchestrator",
                "system_prompt": "You are an orchestrator that receives observations from two agents for a Blocks World instance. Your job is to integrate their observations, resolve any discrepancies, and produce a complete PDDL domain and a PDDL problem encoding the final arrangement of the blocks after the full action sequence. The produced PDDL must be compatible with the FastDownwards planner. Provide both the PDDL domain and the PDDL problem. Enclose the PDDL domain between <domain> and </domain> tags and the PDDL problem between <problem> and </problem> tags. Keep action names and predicates standard for Blocks World (e.g., pickup, putdown, unstack, stack, on, ontable, clear, holding). Explicitly include the final state (goal) as the achieved state in the PDDL problem.",
                "prompt": "You are the orchestrator. Global goal: {agents->orchestrator->goal}. Here is the observation from agent1: {observe_agent1}. Here is the observation from agent2: {observe_agent2}. Reconcile these observations, compute the final arrangement of all blocks (A..J), and produce a PDDL domain and PDDL problem suitable for FastDownwards that encodes that final arrangement as the achieved state. Enclose the domain between <domain></domain> and the problem between <problem></problem>."
            }
        },
        "constraints": [
            "agent1.observe->orchestrator.pddl",
            "agent2.observe->orchestrator.pddl"
        ]
    }
}