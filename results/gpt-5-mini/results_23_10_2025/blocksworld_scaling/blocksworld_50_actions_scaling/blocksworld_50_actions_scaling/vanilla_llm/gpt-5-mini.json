{
  "blocksworld_50_instance_0": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of M, B is on top of E, C is on top of J, D is on top of F, E is on top of L, F is on top of H, G is on top of K, H is on the table, I is on top of C, J is on top of G, K is on top of D, L is on top of A, M is on the table. The agents then execute the following actions in order:\n1. unstack(I, C)\n2. putdown(I)\n3. unstack(C, J)\n4. putdown(C)\n5. pickup(C)\n6. stack(C, I)\n7. unstack(B, E)\n8. putdown(B)\n9. unstack(C, I)\n10. stack(C, J)\n11. unstack(E, L)\n12. stack(E, L)\n13. unstack(E, L)\n14. stack(E, B)\n15. unstack(E, B)\n16. stack(E, L)\n17. pickup(I)\n18. putdown(I)\n19. pickup(I)\n20. stack(I, E)\n21. unstack(I, E)\n22. stack(I, C)\n23. unstack(E, L)\n24. stack(E, L)\n25. pickup(B)\n26. stack(B, E)\n27. unstack(B, E)\n28. stack(B, I)\n29. unstack(B, I)\n30. stack(B, E)\n31. unstack(I, C)\n32. putdown(I)\n33. unstack(C, J)\n34. stack(C, I)\n35. unstack(B, E)\n36. putdown(B)\n37. unstack(C, I)\n38. stack(C, B)\n39. unstack(E, L)\n40. putdown(E)\n41. unstack(C, B)\n42. stack(C, I)\n43. unstack(L, A)\n44. stack(L, C)\n45. pickup(B)\n46. stack(B, A)\n47. unstack(L, C)\n48. stack(L, J)\n49. unstack(B, A)\n50. stack(B, C)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of M, B is on top of E, C is on top of J, D is on top of F, E is on top of L, F is on top of H, G is on top of K, H is on the table, I is on top of C, J is on top of G, K is on top of D, L is on top of A, M is on the table. The agents then execute the following actions in order:\n1. unstack(I, C)\n2. putdown(I)\n3. unstack(C, J)\n4. putdown(C)\n5. pickup(C)\n6. stack(C, I)\n7. unstack(B, E)\n8. putdown(B)\n9. unstack(C, I)\n10. stack(C, J)\n11. unstack(E, L)\n12. stack(E, L)\n13. unstack(E, L)\n14. stack(E, B)\n15. unstack(E, B)\n16. stack(E, L)\n17. pickup(I)\n18. putdown(I)\n19. pickup(I)\n20. stack(I, E)\n21. unstack(I, E)\n22. stack(I, C)\n23. unstack(E, L)\n24. stack(E, L)\n25. pickup(B)\n26. stack(B, E)\n27. unstack(B, E)\n28. stack(B, I)\n29. unstack(B, I)\n30. stack(B, E)\n31. unstack(I, C)\n32. putdown(I)\n33. unstack(C, J)\n34. stack(C, I)\n35. unstack(B, E)\n36. putdown(B)\n37. unstack(C, I)\n38. stack(C, B)\n39. unstack(E, L)\n40. putdown(E)\n41. unstack(C, B)\n42. stack(C, I)\n43. unstack(L, A)\n44. stack(L, C)\n45. pickup(B)\n46. stack(B, A)\n47. unstack(L, C)\n48. stack(L, J)\n49. unstack(B, A)\n50. stack(B, C)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of M, B is on top of C, C is on top of I, D is on top of F, E is on the table, F is on top of H, G is on top of K, H is on the table, I is on the table, J is on top of G, K is on top of D, L is on top of J, M is on the table",
    "response": "Final positions (block : what it is on):\n\nA : on M\nB : on C\nC : on I\nD : on F\nE : on the table\nF : on H\nG : on K\nH : on the table\nI : on the table\nJ : on G\nK : on D\nL : on J\nM : on the table"
  },
  "blocksworld_50_instance_1": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on top of J, B is on the table, C is on top of F, D is on top of H, E is on top of G, F is on the table, G is on top of I, H is on the table, I is on the table, J is on top of E, K is on top of B. The agents then execute the following actions in order:\n1. unstack(D, H)\n2. stack(D, H)\n3. unstack(K, B)\n4. putdown(K)\n5. unstack(A, J)\n6. stack(A, D)\n7. pickup(B)\n8. stack(B, C)\n9. unstack(J, E)\n10. stack(J, A)\n11. unstack(J, A)\n12. stack(J, K)\n13. unstack(A, D)\n14. stack(A, D)\n15. unstack(A, D)\n16. stack(A, B)\n17. unstack(E, G)\n18. stack(E, G)\n19. unstack(D, H)\n20. putdown(D)\n21. pickup(H)\n22. stack(H, E)\n23. unstack(A, B)\n24. putdown(A)\n25. pickup(A)\n26. stack(A, H)\n27. unstack(A, H)\n28. stack(A, D)\n29. unstack(J, K)\n30. stack(J, H)\n31. pickup(K)\n32. stack(K, B)\n33. unstack(K, B)\n34. stack(K, A)\n35. unstack(B, C)\n36. putdown(B)\n37. pickup(B)\n38. putdown(B)\n39. unstack(J, H)\n40. stack(J, B)\n41. unstack(K, A)\n42. stack(K, H)\n43. unstack(J, B)\n44. stack(J, A)\n45. pickup(B)\n46. stack(B, J)\n47. unstack(B, J)\n48. stack(B, C)\n49. unstack(J, A)\n50. stack(J, A)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on top of J, B is on the table, C is on top of F, D is on top of H, E is on top of G, F is on the table, G is on top of I, H is on the table, I is on the table, J is on top of E, K is on top of B. The agents then execute the following actions in order:\n1. unstack(D, H)\n2. stack(D, H)\n3. unstack(K, B)\n4. putdown(K)\n5. unstack(A, J)\n6. stack(A, D)\n7. pickup(B)\n8. stack(B, C)\n9. unstack(J, E)\n10. stack(J, A)\n11. unstack(J, A)\n12. stack(J, K)\n13. unstack(A, D)\n14. stack(A, D)\n15. unstack(A, D)\n16. stack(A, B)\n17. unstack(E, G)\n18. stack(E, G)\n19. unstack(D, H)\n20. putdown(D)\n21. pickup(H)\n22. stack(H, E)\n23. unstack(A, B)\n24. putdown(A)\n25. pickup(A)\n26. stack(A, H)\n27. unstack(A, H)\n28. stack(A, D)\n29. unstack(J, K)\n30. stack(J, H)\n31. pickup(K)\n32. stack(K, B)\n33. unstack(K, B)\n34. stack(K, A)\n35. unstack(B, C)\n36. putdown(B)\n37. pickup(B)\n38. putdown(B)\n39. unstack(J, H)\n40. stack(J, B)\n41. unstack(K, A)\n42. stack(K, H)\n43. unstack(J, B)\n44. stack(J, A)\n45. pickup(B)\n46. stack(B, J)\n47. unstack(B, J)\n48. stack(B, C)\n49. unstack(J, A)\n50. stack(J, A)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of D, B is on top of C, C is on top of F, D is on the table, E is on top of G, F is on the table, G is on top of I, H is on top of E, I is on the table, J is on top of A, K is on top of H",
    "response": "Final configuration (each \"X on Y\" means X is directly on Y; \"on table\" means directly on the table):\n\n- I on table\n- G on I\n- E on G\n- H on E\n- K on H\n\n- F on table\n- C on F\n- B on C\n\n- D on table\n- A on D\n- J on A"
  },
  "blocksworld_50_instance_2": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of K, B is on top of C, C is on the table, D is on top of E, E is on top of I, F is on top of M, G is on the table, H is on top of F, I is on top of G, J is on top of H, K is on top of B, L is on top of A, M is on top of D. The agents then execute the following actions in order:\n1. unstack(J, H)\n2. putdown(J)\n3. pickup(J)\n4. putdown(J)\n5. pickup(J)\n6. stack(J, H)\n7. unstack(J, H)\n8. stack(J, L)\n9. unstack(J, L)\n10. stack(J, H)\n11. unstack(J, H)\n12. stack(J, H)\n13. unstack(J, H)\n14. putdown(J)\n15. pickup(J)\n16. putdown(J)\n17. pickup(J)\n18. stack(J, L)\n19. unstack(J, L)\n20. stack(J, L)\n21. unstack(H, F)\n22. stack(H, J)\n23. unstack(F, M)\n24. stack(F, H)\n25. unstack(F, H)\n26. stack(F, H)\n27. unstack(M, D)\n28. stack(M, D)\n29. unstack(M, D)\n30. stack(M, D)\n31. unstack(M, D)\n32. stack(M, D)\n33. unstack(M, D)\n34. stack(M, F)\n35. unstack(D, E)\n36. stack(D, M)\n37. unstack(D, M)\n38. stack(D, M)\n39. unstack(D, M)\n40. putdown(D)\n41. unstack(E, I)\n42. putdown(E)\n43. unstack(I, G)\n44. putdown(I)\n45. pickup(E)\n46. stack(E, D)\n47. unstack(E, D)\n48. stack(E, M)\n49. pickup(G)\n50. putdown(G)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of K, B is on top of C, C is on the table, D is on top of E, E is on top of I, F is on top of M, G is on the table, H is on top of F, I is on top of G, J is on top of H, K is on top of B, L is on top of A, M is on top of D. The agents then execute the following actions in order:\n1. unstack(J, H)\n2. putdown(J)\n3. pickup(J)\n4. putdown(J)\n5. pickup(J)\n6. stack(J, H)\n7. unstack(J, H)\n8. stack(J, L)\n9. unstack(J, L)\n10. stack(J, H)\n11. unstack(J, H)\n12. stack(J, H)\n13. unstack(J, H)\n14. putdown(J)\n15. pickup(J)\n16. putdown(J)\n17. pickup(J)\n18. stack(J, L)\n19. unstack(J, L)\n20. stack(J, L)\n21. unstack(H, F)\n22. stack(H, J)\n23. unstack(F, M)\n24. stack(F, H)\n25. unstack(F, H)\n26. stack(F, H)\n27. unstack(M, D)\n28. stack(M, D)\n29. unstack(M, D)\n30. stack(M, D)\n31. unstack(M, D)\n32. stack(M, D)\n33. unstack(M, D)\n34. stack(M, F)\n35. unstack(D, E)\n36. stack(D, M)\n37. unstack(D, M)\n38. stack(D, M)\n39. unstack(D, M)\n40. putdown(D)\n41. unstack(E, I)\n42. putdown(E)\n43. unstack(I, G)\n44. putdown(I)\n45. pickup(E)\n46. stack(E, D)\n47. unstack(E, D)\n48. stack(E, M)\n49. pickup(G)\n50. putdown(G)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of K, B is on top of C, C is on the table, D is on the table, E is on top of M, F is on top of H, G is on the table, H is on top of J, I is on the table, J is on top of L, K is on top of B, L is on top of A, M is on top of F",
    "response": "Final positions (each \u201cX on Y\u201d means X is on top of Y; \u201con table\u201d means directly on the table):\n\n- A on K\n- B on C\n- C on table\n- D on table\n- E on M\n- F on H\n- G on table\n- H on J\n- I on table\n- J on L\n- K on B\n- L on A\n- M on F"
  },
  "blocksworld_50_instance_3": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L. The initial arrangement is: A is on top of D, B is on top of K, C is on the table, D is on the table, E is on top of L, F is on top of H, G is on top of I, H is on top of J, I is on top of C, J is on the table, K is on the table, L is on top of A. The agents then execute the following actions in order:\n1. unstack(G, I)\n2. stack(G, E)\n3. unstack(I, C)\n4. stack(I, B)\n5. unstack(I, B)\n6. stack(I, F)\n7. unstack(B, K)\n8. putdown(B)\n9. pickup(C)\n10. putdown(C)\n11. unstack(I, F)\n12. stack(I, F)\n13. pickup(C)\n14. putdown(C)\n15. unstack(G, E)\n16. stack(G, I)\n17. pickup(C)\n18. stack(C, E)\n19. unstack(G, I)\n20. stack(G, K)\n21. unstack(C, E)\n22. stack(C, I)\n23. unstack(G, K)\n24. putdown(G)\n25. pickup(K)\n26. stack(K, G)\n27. unstack(C, I)\n28. stack(C, B)\n29. unstack(I, F)\n30. putdown(I)\n31. unstack(C, B)\n32. stack(C, K)\n33. pickup(B)\n34. stack(B, C)\n35. unstack(F, H)\n36. putdown(F)\n37. pickup(F)\n38. stack(F, I)\n39. unstack(F, I)\n40. putdown(F)\n41. pickup(F)\n42. stack(F, I)\n43. unstack(F, I)\n44. stack(F, I)\n45. unstack(F, I)\n46. stack(F, B)\n47. unstack(F, B)\n48. stack(F, H)\n49. unstack(F, H)\n50. putdown(F)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L. The initial arrangement is: A is on top of D, B is on top of K, C is on the table, D is on the table, E is on top of L, F is on top of H, G is on top of I, H is on top of J, I is on top of C, J is on the table, K is on the table, L is on top of A. The agents then execute the following actions in order:\n1. unstack(G, I)\n2. stack(G, E)\n3. unstack(I, C)\n4. stack(I, B)\n5. unstack(I, B)\n6. stack(I, F)\n7. unstack(B, K)\n8. putdown(B)\n9. pickup(C)\n10. putdown(C)\n11. unstack(I, F)\n12. stack(I, F)\n13. pickup(C)\n14. putdown(C)\n15. unstack(G, E)\n16. stack(G, I)\n17. pickup(C)\n18. stack(C, E)\n19. unstack(G, I)\n20. stack(G, K)\n21. unstack(C, E)\n22. stack(C, I)\n23. unstack(G, K)\n24. putdown(G)\n25. pickup(K)\n26. stack(K, G)\n27. unstack(C, I)\n28. stack(C, B)\n29. unstack(I, F)\n30. putdown(I)\n31. unstack(C, B)\n32. stack(C, K)\n33. pickup(B)\n34. stack(B, C)\n35. unstack(F, H)\n36. putdown(F)\n37. pickup(F)\n38. stack(F, I)\n39. unstack(F, I)\n40. putdown(F)\n41. pickup(F)\n42. stack(F, I)\n43. unstack(F, I)\n44. stack(F, I)\n45. unstack(F, I)\n46. stack(F, B)\n47. unstack(F, B)\n48. stack(F, H)\n49. unstack(F, H)\n50. putdown(F)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of D, B is on top of C, C is on top of K, D is on the table, E is on top of L, F is on the table, G is on the table, H is on top of J, I is on the table, J is on the table, K is on top of G, L is on top of A",
    "response": "Final positions (each block: what it is on):\n\nA is on D\nB is on C\nC is on K\nD is on the table\nE is on L\nF is on the table\nG is on the table\nH is on J\nI is on the table\nJ is on the table\nK is on G\nL is on A\n\n(Equivalently, the table stacks top-to-bottom are: [E, L, A, D], [H, J], [B, C, K, G], [I], [F].)"
  },
  "blocksworld_50_instance_4": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on top of B, B is on top of K, C is on top of J, D is on the table, E is on top of G, F is on the table, G is on the table, H is on top of F, I is on the table, J is on the table, K is on top of C. The agents then execute the following actions in order:\n1. pickup(I)\n2. stack(I, H)\n3. unstack(A, B)\n4. putdown(A)\n5. unstack(I, H)\n6. stack(I, D)\n7. unstack(E, G)\n8. stack(E, H)\n9. unstack(I, D)\n10. stack(I, E)\n11. pickup(A)\n12. stack(A, G)\n13. unstack(I, E)\n14. stack(I, D)\n15. unstack(B, K)\n16. stack(B, I)\n17. unstack(B, I)\n18. stack(B, E)\n19. unstack(I, D)\n20. stack(I, D)\n21. unstack(I, D)\n22. stack(I, D)\n23. unstack(A, G)\n24. stack(A, I)\n25. pickup(G)\n26. stack(G, K)\n27. unstack(B, E)\n28. stack(B, A)\n29. unstack(E, H)\n30. stack(E, G)\n31. unstack(B, A)\n32. stack(B, E)\n33. unstack(A, I)\n34. putdown(A)\n35. unstack(H, F)\n36. putdown(H)\n37. unstack(I, D)\n38. stack(I, F)\n39. pickup(D)\n40. stack(D, A)\n41. unstack(D, A)\n42. stack(D, A)\n43. unstack(B, E)\n44. putdown(B)\n45. pickup(H)\n46. stack(H, I)\n47. unstack(E, G)\n48. stack(E, B)\n49. unstack(D, A)\n50. stack(D, A)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on top of B, B is on top of K, C is on top of J, D is on the table, E is on top of G, F is on the table, G is on the table, H is on top of F, I is on the table, J is on the table, K is on top of C. The agents then execute the following actions in order:\n1. pickup(I)\n2. stack(I, H)\n3. unstack(A, B)\n4. putdown(A)\n5. unstack(I, H)\n6. stack(I, D)\n7. unstack(E, G)\n8. stack(E, H)\n9. unstack(I, D)\n10. stack(I, E)\n11. pickup(A)\n12. stack(A, G)\n13. unstack(I, E)\n14. stack(I, D)\n15. unstack(B, K)\n16. stack(B, I)\n17. unstack(B, I)\n18. stack(B, E)\n19. unstack(I, D)\n20. stack(I, D)\n21. unstack(I, D)\n22. stack(I, D)\n23. unstack(A, G)\n24. stack(A, I)\n25. pickup(G)\n26. stack(G, K)\n27. unstack(B, E)\n28. stack(B, A)\n29. unstack(E, H)\n30. stack(E, G)\n31. unstack(B, A)\n32. stack(B, E)\n33. unstack(A, I)\n34. putdown(A)\n35. unstack(H, F)\n36. putdown(H)\n37. unstack(I, D)\n38. stack(I, F)\n39. pickup(D)\n40. stack(D, A)\n41. unstack(D, A)\n42. stack(D, A)\n43. unstack(B, E)\n44. putdown(B)\n45. pickup(H)\n46. stack(H, I)\n47. unstack(E, G)\n48. stack(E, B)\n49. unstack(D, A)\n50. stack(D, A)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on the table, C is on top of J, D is on top of A, E is on top of B, F is on the table, G is on top of K, H is on top of I, I is on top of F, J is on the table, K is on top of C",
    "response": "Final positions (block : what it is on)\n\n- A : on the table  \n- B : on the table  \n- C : on J  \n- D : on A  \n- E : on B  \n- F : on the table  \n- G : on K  \n- H : on I  \n- I : on F  \n- J : on the table  \n- K : on C\n\n(Equivalently, the table stacks are: [A - D], [B - E], [F - I - H], [J - C - K - G].)"
  },
  "blocksworld_50_instance_5": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of L, B is on the table, C is on the table, D is on top of B, E is on top of F, F is on the table, G is on the table, H is on top of M, I is on top of G, J is on top of D, K is on top of C, L is on the table, M is on top of A. The agents then execute the following actions in order:\n1. unstack(J, D)\n2. stack(J, E)\n3. unstack(J, E)\n4. putdown(J)\n5. unstack(H, M)\n6. stack(H, E)\n7. unstack(H, E)\n8. stack(H, I)\n9. unstack(H, I)\n10. stack(H, E)\n11. unstack(K, C)\n12. stack(K, J)\n13. unstack(K, J)\n14. stack(K, D)\n15. unstack(M, A)\n16. stack(M, I)\n17. pickup(J)\n18. putdown(J)\n19. pickup(J)\n20. stack(J, M)\n21. unstack(J, M)\n22. stack(J, A)\n23. unstack(K, D)\n24. stack(K, D)\n25. unstack(J, A)\n26. stack(J, C)\n27. unstack(J, C)\n28. stack(J, H)\n29. unstack(J, H)\n30. stack(J, C)\n31. unstack(H, E)\n32. stack(H, A)\n33. unstack(H, A)\n34. stack(H, J)\n35. unstack(K, D)\n36. stack(K, A)\n37. unstack(H, J)\n38. stack(H, D)\n39. unstack(J, C)\n40. stack(J, C)\n41. unstack(H, D)\n42. stack(H, J)\n43. unstack(D, B)\n44. stack(D, H)\n45. unstack(E, F)\n46. putdown(E)\n47. pickup(F)\n48. stack(F, B)\n49. unstack(M, I)\n50. putdown(M)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of L, B is on the table, C is on the table, D is on top of B, E is on top of F, F is on the table, G is on the table, H is on top of M, I is on top of G, J is on top of D, K is on top of C, L is on the table, M is on top of A. The agents then execute the following actions in order:\n1. unstack(J, D)\n2. stack(J, E)\n3. unstack(J, E)\n4. putdown(J)\n5. unstack(H, M)\n6. stack(H, E)\n7. unstack(H, E)\n8. stack(H, I)\n9. unstack(H, I)\n10. stack(H, E)\n11. unstack(K, C)\n12. stack(K, J)\n13. unstack(K, J)\n14. stack(K, D)\n15. unstack(M, A)\n16. stack(M, I)\n17. pickup(J)\n18. putdown(J)\n19. pickup(J)\n20. stack(J, M)\n21. unstack(J, M)\n22. stack(J, A)\n23. unstack(K, D)\n24. stack(K, D)\n25. unstack(J, A)\n26. stack(J, C)\n27. unstack(J, C)\n28. stack(J, H)\n29. unstack(J, H)\n30. stack(J, C)\n31. unstack(H, E)\n32. stack(H, A)\n33. unstack(H, A)\n34. stack(H, J)\n35. unstack(K, D)\n36. stack(K, A)\n37. unstack(H, J)\n38. stack(H, D)\n39. unstack(J, C)\n40. stack(J, C)\n41. unstack(H, D)\n42. stack(H, J)\n43. unstack(D, B)\n44. stack(D, H)\n45. unstack(E, F)\n46. putdown(E)\n47. pickup(F)\n48. stack(F, B)\n49. unstack(M, I)\n50. putdown(M)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of L, B is on the table, C is on the table, D is on top of H, E is on the table, F is on top of B, G is on the table, H is on top of J, I is on top of G, J is on top of C, K is on top of A, L is on the table, M is on the table",
    "response": "Final positions:\n\n- A is on L.\n- B is on the table.\n- C is on the table.\n- D is on H.\n- E is on the table.\n- F is on B.\n- G is on the table.\n- H is on J.\n- I is on G.\n- J is on C.\n- K is on A.\n- L is on the table.\n- M is on the table."
  },
  "blocksworld_50_instance_6": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on top of F, B is on top of C, C is on top of E, D is on the table, E is on top of G, F is on top of H, G is on top of D, H is on top of B, I is on the table, J is on top of I. The agents then execute the following actions in order:\n1. unstack(A, F)\n2. stack(A, J)\n3. unstack(F, H)\n4. putdown(F)\n5. pickup(F)\n6. stack(F, H)\n7. unstack(F, H)\n8. putdown(F)\n9. pickup(F)\n10. stack(F, H)\n11. unstack(F, H)\n12. stack(F, A)\n13. unstack(H, B)\n14. putdown(H)\n15. unstack(B, C)\n16. stack(B, C)\n17. pickup(H)\n18. stack(H, F)\n19. unstack(B, C)\n20. stack(B, C)\n21. unstack(H, F)\n22. stack(H, F)\n23. unstack(H, F)\n24. stack(H, B)\n25. unstack(F, A)\n26. putdown(F)\n27. unstack(H, B)\n28. stack(H, F)\n29. unstack(B, C)\n30. stack(B, C)\n31. unstack(A, J)\n32. stack(A, H)\n33. unstack(A, H)\n34. putdown(A)\n35. unstack(B, C)\n36. putdown(B)\n37. unstack(H, F)\n38. stack(H, C)\n39. pickup(B)\n40. putdown(B)\n41. unstack(H, C)\n42. stack(H, J)\n43. pickup(F)\n44. stack(F, A)\n45. pickup(B)\n46. stack(B, F)\n47. unstack(H, J)\n48. putdown(H)\n49. unstack(C, E)\n50. stack(C, H)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on top of F, B is on top of C, C is on top of E, D is on the table, E is on top of G, F is on top of H, G is on top of D, H is on top of B, I is on the table, J is on top of I. The agents then execute the following actions in order:\n1. unstack(A, F)\n2. stack(A, J)\n3. unstack(F, H)\n4. putdown(F)\n5. pickup(F)\n6. stack(F, H)\n7. unstack(F, H)\n8. putdown(F)\n9. pickup(F)\n10. stack(F, H)\n11. unstack(F, H)\n12. stack(F, A)\n13. unstack(H, B)\n14. putdown(H)\n15. unstack(B, C)\n16. stack(B, C)\n17. pickup(H)\n18. stack(H, F)\n19. unstack(B, C)\n20. stack(B, C)\n21. unstack(H, F)\n22. stack(H, F)\n23. unstack(H, F)\n24. stack(H, B)\n25. unstack(F, A)\n26. putdown(F)\n27. unstack(H, B)\n28. stack(H, F)\n29. unstack(B, C)\n30. stack(B, C)\n31. unstack(A, J)\n32. stack(A, H)\n33. unstack(A, H)\n34. putdown(A)\n35. unstack(B, C)\n36. putdown(B)\n37. unstack(H, F)\n38. stack(H, C)\n39. pickup(B)\n40. putdown(B)\n41. unstack(H, C)\n42. stack(H, J)\n43. pickup(F)\n44. stack(F, A)\n45. pickup(B)\n46. stack(B, F)\n47. unstack(H, J)\n48. putdown(H)\n49. unstack(C, E)\n50. stack(C, H)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on top of F, C is on top of H, D is on the table, E is on top of G, F is on top of A, G is on top of D, H is on the table, I is on the table, J is on top of I",
    "response": "Final \"on\" relations (block : what it is on):\n\n- A : on the table\n- B : on F\n- C : on H\n- D : on the table\n- E : on G\n- F : on A\n- G : on D\n- H : on the table\n- I : on the table\n- J : on I\n\n(Stacks: D-G-E; A-F-B; H-C; I-J.)"
  },
  "blocksworld_50_instance_7": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of F, B is on top of H, C is on top of D, D is on top of E, E is on the table, F is on top of L, G is on the table, H is on top of I, I is on the table, J is on the table, K is on top of M, L is on top of J, M is on top of G. The agents then execute the following actions in order:\n1. unstack(K, M)\n2. stack(K, C)\n3. unstack(B, H)\n4. putdown(B)\n5. unstack(K, C)\n6. stack(K, A)\n7. unstack(K, A)\n8. stack(K, B)\n9. unstack(K, B)\n10. stack(K, A)\n11. pickup(B)\n12. stack(B, C)\n13. unstack(K, A)\n14. stack(K, A)\n15. unstack(M, G)\n16. stack(M, K)\n17. unstack(H, I)\n18. stack(H, I)\n19. unstack(B, C)\n20. stack(B, G)\n21. unstack(M, K)\n22. stack(M, C)\n23. unstack(B, G)\n24. stack(B, H)\n25. unstack(B, H)\n26. stack(B, G)\n27. unstack(K, A)\n28. stack(K, B)\n29. unstack(H, I)\n30. stack(H, K)\n31. unstack(H, K)\n32. stack(H, I)\n33. unstack(K, B)\n34. stack(K, M)\n35. unstack(H, I)\n36. stack(H, B)\n37. unstack(A, F)\n38. stack(A, F)\n39. unstack(A, F)\n40. putdown(A)\n41. pickup(I)\n42. putdown(I)\n43. pickup(I)\n44. stack(I, F)\n45. unstack(K, M)\n46. stack(K, M)\n47. unstack(K, M)\n48. stack(K, H)\n49. unstack(M, C)\n50. putdown(M)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M. The initial arrangement is: A is on top of F, B is on top of H, C is on top of D, D is on top of E, E is on the table, F is on top of L, G is on the table, H is on top of I, I is on the table, J is on the table, K is on top of M, L is on top of J, M is on top of G. The agents then execute the following actions in order:\n1. unstack(K, M)\n2. stack(K, C)\n3. unstack(B, H)\n4. putdown(B)\n5. unstack(K, C)\n6. stack(K, A)\n7. unstack(K, A)\n8. stack(K, B)\n9. unstack(K, B)\n10. stack(K, A)\n11. pickup(B)\n12. stack(B, C)\n13. unstack(K, A)\n14. stack(K, A)\n15. unstack(M, G)\n16. stack(M, K)\n17. unstack(H, I)\n18. stack(H, I)\n19. unstack(B, C)\n20. stack(B, G)\n21. unstack(M, K)\n22. stack(M, C)\n23. unstack(B, G)\n24. stack(B, H)\n25. unstack(B, H)\n26. stack(B, G)\n27. unstack(K, A)\n28. stack(K, B)\n29. unstack(H, I)\n30. stack(H, K)\n31. unstack(H, K)\n32. stack(H, I)\n33. unstack(K, B)\n34. stack(K, M)\n35. unstack(H, I)\n36. stack(H, B)\n37. unstack(A, F)\n38. stack(A, F)\n39. unstack(A, F)\n40. putdown(A)\n41. pickup(I)\n42. putdown(I)\n43. pickup(I)\n44. stack(I, F)\n45. unstack(K, M)\n46. stack(K, M)\n47. unstack(K, M)\n48. stack(K, H)\n49. unstack(M, C)\n50. putdown(M)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on top of G, C is on top of D, D is on top of E, E is on the table, F is on top of L, G is on the table, H is on top of B, I is on top of F, J is on the table, K is on top of H, L is on top of J, M is on the table",
    "response": "Final arrangement (each \"X on Y\" means X is on top of Y; \"on table\" means directly on the table):\n\n- A on table  \n- B on G  \n- C on D  \n- D on E  \n- E on table  \n- F on L  \n- G on table  \n- H on B  \n- I on F  \n- J on table  \n- K on H  \n- L on J  \n- M on table\n\nEquivalently, the final stacks (top \u2192 ... \u2192 table) are:\n- I \u2192 F \u2192 L \u2192 J \u2192 table  \n- C \u2192 D \u2192 E \u2192 table  \n- K \u2192 H \u2192 B \u2192 G \u2192 table  \n- A \u2192 table  \n- M \u2192 table"
  },
  "blocksworld_50_instance_8": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of H, B is on top of L, C is on top of A, D is on the table, E is on the table, F is on top of M, G is on top of N, H is on top of F, I is on top of G, J is on top of D, K is on top of E, L is on the table, M is on top of J, N is on the table. The agents then execute the following actions in order:\n1. unstack(K, E)\n2. stack(K, C)\n3. unstack(B, L)\n4. stack(B, L)\n5. pickup(E)\n6. putdown(E)\n7. unstack(I, G)\n8. stack(I, G)\n9. pickup(E)\n10. stack(E, K)\n11. unstack(I, G)\n12. putdown(I)\n13. unstack(B, L)\n14. stack(B, I)\n15. unstack(E, K)\n16. stack(E, L)\n17. unstack(K, C)\n18. stack(K, C)\n19. unstack(G, N)\n20. stack(G, N)\n21. unstack(G, N)\n22. stack(G, K)\n23. unstack(E, L)\n24. stack(E, L)\n25. unstack(G, K)\n26. stack(G, N)\n27. unstack(E, L)\n28. putdown(E)\n29. unstack(K, C)\n30. stack(K, L)\n31. unstack(K, L)\n32. stack(K, L)\n33. unstack(C, A)\n34. stack(C, E)\n35. unstack(B, I)\n36. stack(B, K)\n37. unstack(C, E)\n38. stack(C, E)\n39. unstack(G, N)\n40. putdown(G)\n41. pickup(G)\n42. stack(G, B)\n43. pickup(N)\n44. stack(N, G)\n45. unstack(A, H)\n46. putdown(A)\n47. pickup(A)\n48. stack(A, H)\n49. unstack(N, G)\n50. stack(N, A)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of H, B is on top of L, C is on top of A, D is on the table, E is on the table, F is on top of M, G is on top of N, H is on top of F, I is on top of G, J is on top of D, K is on top of E, L is on the table, M is on top of J, N is on the table. The agents then execute the following actions in order:\n1. unstack(K, E)\n2. stack(K, C)\n3. unstack(B, L)\n4. stack(B, L)\n5. pickup(E)\n6. putdown(E)\n7. unstack(I, G)\n8. stack(I, G)\n9. pickup(E)\n10. stack(E, K)\n11. unstack(I, G)\n12. putdown(I)\n13. unstack(B, L)\n14. stack(B, I)\n15. unstack(E, K)\n16. stack(E, L)\n17. unstack(K, C)\n18. stack(K, C)\n19. unstack(G, N)\n20. stack(G, N)\n21. unstack(G, N)\n22. stack(G, K)\n23. unstack(E, L)\n24. stack(E, L)\n25. unstack(G, K)\n26. stack(G, N)\n27. unstack(E, L)\n28. putdown(E)\n29. unstack(K, C)\n30. stack(K, L)\n31. unstack(K, L)\n32. stack(K, L)\n33. unstack(C, A)\n34. stack(C, E)\n35. unstack(B, I)\n36. stack(B, K)\n37. unstack(C, E)\n38. stack(C, E)\n39. unstack(G, N)\n40. putdown(G)\n41. pickup(G)\n42. stack(G, B)\n43. pickup(N)\n44. stack(N, G)\n45. unstack(A, H)\n46. putdown(A)\n47. pickup(A)\n48. stack(A, H)\n49. unstack(N, G)\n50. stack(N, A)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of H, B is on top of K, C is on top of E, D is on the table, E is on the table, F is on top of M, G is on top of B, H is on top of F, I is on the table, J is on top of D, K is on top of L, L is on the table, M is on top of J, N is on top of A",
    "response": "Final positions (for each block, what it is directly on):\n\n- A is on H\n- B is on K\n- C is on E\n- D is on the table\n- E is on the table\n- F is on M\n- G is on B\n- H is on F\n- I is on the table\n- J is on D\n- K is on L\n- L is on the table\n- M is on J\n- N is on A"
  },
  "blocksworld_50_instance_9": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of L, B is on top of F, C is on top of M, D is on top of J, E is on top of G, F is on top of I, G is on the table, H is on top of D, I is on top of E, J is on top of A, K is on top of B, L is on the table, M is on top of H, N is on top of C. The agents then execute the following actions in order:\n1. unstack(N, C)\n2. putdown(N)\n3. pickup(N)\n4. putdown(N)\n5. unstack(K, B)\n6. putdown(K)\n7. unstack(B, F)\n8. stack(B, C)\n9. unstack(F, I)\n10. stack(F, I)\n11. unstack(B, C)\n12. stack(B, N)\n13. unstack(F, I)\n14. stack(F, I)\n15. unstack(F, I)\n16. stack(F, B)\n17. unstack(I, E)\n18. stack(I, F)\n19. pickup(K)\n20. stack(K, I)\n21. unstack(K, I)\n22. putdown(K)\n23. unstack(E, G)\n24. stack(E, G)\n25. unstack(C, M)\n26. stack(C, M)\n27. unstack(E, G)\n28. stack(E, I)\n29. pickup(G)\n30. putdown(G)\n31. unstack(C, M)\n32. putdown(C)\n33. pickup(K)\n34. stack(K, E)\n35. unstack(M, H)\n36. putdown(M)\n37. pickup(C)\n38. stack(C, H)\n39. unstack(K, E)\n40. stack(K, C)\n41. unstack(K, C)\n42. stack(K, G)\n43. unstack(C, H)\n44. putdown(C)\n45. pickup(C)\n46. stack(C, E)\n47. unstack(H, D)\n48. stack(H, C)\n49. pickup(M)\n50. putdown(M)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of L, B is on top of F, C is on top of M, D is on top of J, E is on top of G, F is on top of I, G is on the table, H is on top of D, I is on top of E, J is on top of A, K is on top of B, L is on the table, M is on top of H, N is on top of C. The agents then execute the following actions in order:\n1. unstack(N, C)\n2. putdown(N)\n3. pickup(N)\n4. putdown(N)\n5. unstack(K, B)\n6. putdown(K)\n7. unstack(B, F)\n8. stack(B, C)\n9. unstack(F, I)\n10. stack(F, I)\n11. unstack(B, C)\n12. stack(B, N)\n13. unstack(F, I)\n14. stack(F, I)\n15. unstack(F, I)\n16. stack(F, B)\n17. unstack(I, E)\n18. stack(I, F)\n19. pickup(K)\n20. stack(K, I)\n21. unstack(K, I)\n22. putdown(K)\n23. unstack(E, G)\n24. stack(E, G)\n25. unstack(C, M)\n26. stack(C, M)\n27. unstack(E, G)\n28. stack(E, I)\n29. pickup(G)\n30. putdown(G)\n31. unstack(C, M)\n32. putdown(C)\n33. pickup(K)\n34. stack(K, E)\n35. unstack(M, H)\n36. putdown(M)\n37. pickup(C)\n38. stack(C, H)\n39. unstack(K, E)\n40. stack(K, C)\n41. unstack(K, C)\n42. stack(K, G)\n43. unstack(C, H)\n44. putdown(C)\n45. pickup(C)\n46. stack(C, E)\n47. unstack(H, D)\n48. stack(H, C)\n49. pickup(M)\n50. putdown(M)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of L, B is on top of N, C is on top of E, D is on top of J, E is on top of I, F is on top of B, G is on the table, H is on top of C, I is on top of F, J is on top of A, K is on top of G, L is on the table, M is on the table, N is on the table",
    "response": "Final \"on\" relation for each block:\n\nA on L\nB on N\nC on E\nD on J\nE on I\nF on B\nG on the table\nH on C\nI on F\nJ on A\nK on G\nL on the table\nM on the table\nN on the table"
  },
  "blocksworld_50_instance_10": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on top of B, B is on top of J, C is on top of F, D is on top of E, E is on the table, F is on top of H, G is on the table, H is on top of G, I is on top of A, J is on top of D. The agents then execute the following actions in order:\n1. unstack(C, F)\n2. stack(C, I)\n3. unstack(F, H)\n4. stack(F, C)\n5. unstack(H, G)\n6. putdown(H)\n7. pickup(G)\n8. stack(G, H)\n9. unstack(F, C)\n10. putdown(F)\n11. pickup(F)\n12. stack(F, C)\n13. unstack(G, H)\n14. putdown(G)\n15. unstack(F, C)\n16. stack(F, C)\n17. unstack(F, C)\n18. putdown(F)\n19. pickup(F)\n20. putdown(F)\n21. pickup(G)\n22. stack(G, F)\n23. unstack(C, I)\n24. stack(C, H)\n25. unstack(G, F)\n26. stack(G, I)\n27. unstack(C, H)\n28. stack(C, H)\n29. pickup(F)\n30. stack(F, G)\n31. unstack(F, G)\n32. stack(F, G)\n33. unstack(C, H)\n34. stack(C, H)\n35. unstack(F, G)\n36. stack(F, C)\n37. unstack(F, C)\n38. putdown(F)\n39. unstack(G, I)\n40. stack(G, I)\n41. unstack(G, I)\n42. putdown(G)\n43. pickup(G)\n44. stack(G, I)\n45. pickup(F)\n46. stack(F, C)\n47. unstack(G, I)\n48. stack(G, F)\n49. unstack(G, F)\n50. stack(G, F)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on top of B, B is on top of J, C is on top of F, D is on top of E, E is on the table, F is on top of H, G is on the table, H is on top of G, I is on top of A, J is on top of D. The agents then execute the following actions in order:\n1. unstack(C, F)\n2. stack(C, I)\n3. unstack(F, H)\n4. stack(F, C)\n5. unstack(H, G)\n6. putdown(H)\n7. pickup(G)\n8. stack(G, H)\n9. unstack(F, C)\n10. putdown(F)\n11. pickup(F)\n12. stack(F, C)\n13. unstack(G, H)\n14. putdown(G)\n15. unstack(F, C)\n16. stack(F, C)\n17. unstack(F, C)\n18. putdown(F)\n19. pickup(F)\n20. putdown(F)\n21. pickup(G)\n22. stack(G, F)\n23. unstack(C, I)\n24. stack(C, H)\n25. unstack(G, F)\n26. stack(G, I)\n27. unstack(C, H)\n28. stack(C, H)\n29. pickup(F)\n30. stack(F, G)\n31. unstack(F, G)\n32. stack(F, G)\n33. unstack(C, H)\n34. stack(C, H)\n35. unstack(F, G)\n36. stack(F, C)\n37. unstack(F, C)\n38. putdown(F)\n39. unstack(G, I)\n40. stack(G, I)\n41. unstack(G, I)\n42. putdown(G)\n43. pickup(G)\n44. stack(G, I)\n45. pickup(F)\n46. stack(F, C)\n47. unstack(G, I)\n48. stack(G, F)\n49. unstack(G, F)\n50. stack(G, F)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of B, B is on top of J, C is on top of H, D is on top of E, E is on the table, F is on top of C, G is on top of F, H is on the table, I is on top of A, J is on top of D",
    "response": "Final stacks (bottom \u2192 top):\n\n- Stack 1: E (table) \u2192 D \u2192 J \u2192 B \u2192 A \u2192 I\n- Stack 2: H (table) \u2192 C \u2192 F \u2192 G\n\nEquivalently, for each block:\n- A is on B\n- B is on J\n- C is on H\n- D is on E\n- E is on the table\n- F is on C\n- G is on F\n- H is on the table\n- I is on A\n- J is on D"
  },
  "blocksworld_50_instance_11": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on the table, B is on top of D, C is on top of A, D is on top of K, E is on top of H, F is on the table, G is on the table, H is on the table, I is on top of C, J is on top of G, K is on the table. The agents then execute the following actions in order:\n1. unstack(J, G)\n2. putdown(J)\n3. unstack(I, C)\n4. stack(I, J)\n5. unstack(E, H)\n6. stack(E, B)\n7. unstack(E, B)\n8. stack(E, H)\n9. unstack(E, H)\n10. stack(E, C)\n11. unstack(E, C)\n12. stack(E, I)\n13. pickup(H)\n14. putdown(H)\n15. pickup(F)\n16. stack(F, G)\n17. unstack(E, I)\n18. stack(E, C)\n19. unstack(F, G)\n20. stack(F, B)\n21. unstack(F, B)\n22. stack(F, I)\n23. unstack(F, I)\n24. stack(F, E)\n25. unstack(I, J)\n26. stack(I, G)\n27. unstack(I, G)\n28. stack(I, B)\n29. pickup(J)\n30. putdown(J)\n31. unstack(F, E)\n32. stack(F, E)\n33. unstack(F, E)\n34. stack(F, J)\n35. unstack(I, B)\n36. stack(I, E)\n37. pickup(G)\n38. stack(G, F)\n39. pickup(H)\n40. stack(H, I)\n41. unstack(H, I)\n42. putdown(H)\n43. unstack(B, D)\n44. stack(B, H)\n45. unstack(B, H)\n46. putdown(B)\n47. unstack(G, F)\n48. stack(G, F)\n49. unstack(D, K)\n50. stack(D, B)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on the table, B is on top of D, C is on top of A, D is on top of K, E is on top of H, F is on the table, G is on the table, H is on the table, I is on top of C, J is on top of G, K is on the table. The agents then execute the following actions in order:\n1. unstack(J, G)\n2. putdown(J)\n3. unstack(I, C)\n4. stack(I, J)\n5. unstack(E, H)\n6. stack(E, B)\n7. unstack(E, B)\n8. stack(E, H)\n9. unstack(E, H)\n10. stack(E, C)\n11. unstack(E, C)\n12. stack(E, I)\n13. pickup(H)\n14. putdown(H)\n15. pickup(F)\n16. stack(F, G)\n17. unstack(E, I)\n18. stack(E, C)\n19. unstack(F, G)\n20. stack(F, B)\n21. unstack(F, B)\n22. stack(F, I)\n23. unstack(F, I)\n24. stack(F, E)\n25. unstack(I, J)\n26. stack(I, G)\n27. unstack(I, G)\n28. stack(I, B)\n29. pickup(J)\n30. putdown(J)\n31. unstack(F, E)\n32. stack(F, E)\n33. unstack(F, E)\n34. stack(F, J)\n35. unstack(I, B)\n36. stack(I, E)\n37. pickup(G)\n38. stack(G, F)\n39. pickup(H)\n40. stack(H, I)\n41. unstack(H, I)\n42. putdown(H)\n43. unstack(B, D)\n44. stack(B, H)\n45. unstack(B, H)\n46. putdown(B)\n47. unstack(G, F)\n48. stack(G, F)\n49. unstack(D, K)\n50. stack(D, B)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on the table, C is on top of A, D is on top of B, E is on top of C, F is on top of J, G is on top of F, H is on the table, I is on top of E, J is on the table, K is on the table",
    "response": "Final stacks (bottom \u2192 top) and each block's support:\n\n- Stack 1: A \u2192 C \u2192 E \u2192 I\n  - A: on the table\n  - C: on A\n  - E: on C\n  - I: on E\n\n- Stack 2: B \u2192 D\n  - B: on the table\n  - D: on B\n\n- Stack 3: J \u2192 F \u2192 G\n  - J: on the table\n  - F: on J\n  - G: on F\n\n- Stack 4: H\n  - H: on the table\n\n- Stack 5: K\n  - K: on the table\n\n(Every block A\u2013K is listed above.)"
  },
  "blocksworld_50_instance_12": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on the table, B is on top of F, C is on top of I, D is on top of C, E is on top of M, F is on top of E, G is on the table, H is on top of J, I is on top of H, J is on top of A, K is on top of L, L is on top of N, M is on the table, N is on top of B. The agents then execute the following actions in order:\n1. pickup(G)\n2. stack(G, D)\n3. unstack(K, L)\n4. putdown(K)\n5. pickup(K)\n6. putdown(K)\n7. pickup(K)\n8. stack(K, G)\n9. unstack(L, N)\n10. stack(L, K)\n11. unstack(L, K)\n12. stack(L, N)\n13. unstack(L, N)\n14. stack(L, N)\n15. unstack(K, G)\n16. stack(K, G)\n17. unstack(K, G)\n18. putdown(K)\n19. pickup(K)\n20. stack(K, L)\n21. unstack(K, L)\n22. putdown(K)\n23. unstack(L, N)\n24. stack(L, N)\n25. unstack(G, D)\n26. stack(G, D)\n27. pickup(K)\n28. putdown(K)\n29. unstack(G, D)\n30. stack(G, D)\n31. unstack(G, D)\n32. stack(G, K)\n33. unstack(L, N)\n34. putdown(L)\n35. unstack(D, C)\n36. stack(D, G)\n37. pickup(L)\n38. stack(L, C)\n39. unstack(L, C)\n40. stack(L, C)\n41. unstack(N, B)\n42. stack(N, L)\n43. unstack(D, G)\n44. stack(D, B)\n45. unstack(N, L)\n46. putdown(N)\n47. pickup(N)\n48. stack(N, L)\n49. unstack(N, L)\n50. stack(N, D)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on the table, B is on top of F, C is on top of I, D is on top of C, E is on top of M, F is on top of E, G is on the table, H is on top of J, I is on top of H, J is on top of A, K is on top of L, L is on top of N, M is on the table, N is on top of B. The agents then execute the following actions in order:\n1. pickup(G)\n2. stack(G, D)\n3. unstack(K, L)\n4. putdown(K)\n5. pickup(K)\n6. putdown(K)\n7. pickup(K)\n8. stack(K, G)\n9. unstack(L, N)\n10. stack(L, K)\n11. unstack(L, K)\n12. stack(L, N)\n13. unstack(L, N)\n14. stack(L, N)\n15. unstack(K, G)\n16. stack(K, G)\n17. unstack(K, G)\n18. putdown(K)\n19. pickup(K)\n20. stack(K, L)\n21. unstack(K, L)\n22. putdown(K)\n23. unstack(L, N)\n24. stack(L, N)\n25. unstack(G, D)\n26. stack(G, D)\n27. pickup(K)\n28. putdown(K)\n29. unstack(G, D)\n30. stack(G, D)\n31. unstack(G, D)\n32. stack(G, K)\n33. unstack(L, N)\n34. putdown(L)\n35. unstack(D, C)\n36. stack(D, G)\n37. pickup(L)\n38. stack(L, C)\n39. unstack(L, C)\n40. stack(L, C)\n41. unstack(N, B)\n42. stack(N, L)\n43. unstack(D, G)\n44. stack(D, B)\n45. unstack(N, L)\n46. putdown(N)\n47. pickup(N)\n48. stack(N, L)\n49. unstack(N, L)\n50. stack(N, D)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on top of F, C is on top of I, D is on top of B, E is on top of M, F is on top of E, G is on top of K, H is on top of J, I is on top of H, J is on top of A, K is on the table, L is on top of C, M is on the table, N is on top of D",
    "response": "Final stacks (bottom -> top):\n\n- Stack 1: A, J, H, I, C, L\n- Stack 2: M, E, F, B, D, N\n- Stack 3: K, G\n\nSo, for each block:\n\n- A: on the table  \n- J: on A  \n- H: on J  \n- I: on H  \n- C: on I  \n- L: on C  \n\n- M: on the table  \n- E: on M  \n- F: on E  \n- B: on F  \n- D: on B  \n- N: on D  \n\n- K: on the table  \n- G: on K"
  },
  "blocksworld_50_instance_13": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on the table, B is on top of A, C is on the table, D is on top of E, E is on top of G, F is on top of C, G is on top of K, H is on top of B, I is on top of H, J is on top of F, K is on top of J. The agents then execute the following actions in order:\n1. unstack(I, H)\n2. putdown(I)\n3. pickup(I)\n4. stack(I, H)\n5. unstack(D, E)\n6. stack(D, E)\n7. unstack(D, E)\n8. stack(D, I)\n9. unstack(D, I)\n10. stack(D, E)\n11. unstack(I, H)\n12. putdown(I)\n13. unstack(H, B)\n14. stack(H, I)\n15. unstack(B, A)\n16. putdown(B)\n17. pickup(B)\n18. stack(B, H)\n19. pickup(A)\n20. putdown(A)\n21. pickup(A)\n22. putdown(A)\n23. pickup(A)\n24. stack(A, B)\n25. unstack(D, E)\n26. putdown(D)\n27. unstack(A, B)\n28. stack(A, D)\n29. unstack(B, H)\n30. stack(B, H)\n31. unstack(E, G)\n32. putdown(E)\n33. pickup(E)\n34. stack(E, A)\n35. unstack(G, K)\n36. putdown(G)\n37. unstack(B, H)\n38. stack(B, H)\n39. unstack(E, A)\n40. stack(E, A)\n41. pickup(G)\n42. putdown(G)\n43. unstack(K, J)\n44. stack(K, G)\n45. unstack(K, G)\n46. stack(K, J)\n47. pickup(G)\n48. putdown(G)\n49. unstack(B, H)\n50. stack(B, G)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K. The initial arrangement is: A is on the table, B is on top of A, C is on the table, D is on top of E, E is on top of G, F is on top of C, G is on top of K, H is on top of B, I is on top of H, J is on top of F, K is on top of J. The agents then execute the following actions in order:\n1. unstack(I, H)\n2. putdown(I)\n3. pickup(I)\n4. stack(I, H)\n5. unstack(D, E)\n6. stack(D, E)\n7. unstack(D, E)\n8. stack(D, I)\n9. unstack(D, I)\n10. stack(D, E)\n11. unstack(I, H)\n12. putdown(I)\n13. unstack(H, B)\n14. stack(H, I)\n15. unstack(B, A)\n16. putdown(B)\n17. pickup(B)\n18. stack(B, H)\n19. pickup(A)\n20. putdown(A)\n21. pickup(A)\n22. putdown(A)\n23. pickup(A)\n24. stack(A, B)\n25. unstack(D, E)\n26. putdown(D)\n27. unstack(A, B)\n28. stack(A, D)\n29. unstack(B, H)\n30. stack(B, H)\n31. unstack(E, G)\n32. putdown(E)\n33. pickup(E)\n34. stack(E, A)\n35. unstack(G, K)\n36. putdown(G)\n37. unstack(B, H)\n38. stack(B, H)\n39. unstack(E, A)\n40. stack(E, A)\n41. pickup(G)\n42. putdown(G)\n43. unstack(K, J)\n44. stack(K, G)\n45. unstack(K, G)\n46. stack(K, J)\n47. pickup(G)\n48. putdown(G)\n49. unstack(B, H)\n50. stack(B, G)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of D, B is on top of G, C is on the table, D is on the table, E is on top of A, F is on top of C, G is on the table, H is on top of I, I is on the table, J is on top of F, K is on top of J",
    "response": "Final stacks (bottom -> top):\n- C - F - J - K\n- I - H\n- D - A - E\n- G - B\n\nEquivalently, for each block:\n- A is on D\n- B is on G\n- C is on the table\n- D is on the table\n- E is on A\n- F is on C\n- G is on the table\n- H is on I\n- I is on the table\n- J is on F\n- K is on J"
  },
  "blocksworld_50_instance_14": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of B, B is on top of J, C is on top of I, D is on top of G, E is on the table, F is on the table, G is on top of E, H is on top of L, I is on top of N, J is on top of D, K is on top of H, L is on the table, M is on top of F, N is on the table. The agents then execute the following actions in order:\n1. unstack(A, B)\n2. putdown(A)\n3. unstack(K, H)\n4. putdown(K)\n5. unstack(C, I)\n6. stack(C, M)\n7. pickup(A)\n8. stack(A, I)\n9. unstack(A, I)\n10. stack(A, H)\n11. unstack(B, J)\n12. stack(B, I)\n13. unstack(C, M)\n14. stack(C, M)\n15. unstack(C, M)\n16. stack(C, A)\n17. pickup(K)\n18. stack(K, J)\n19. unstack(M, F)\n20. putdown(M)\n21. pickup(M)\n22. stack(M, F)\n23. unstack(B, I)\n24. stack(B, C)\n25. unstack(K, J)\n26. putdown(K)\n27. unstack(I, N)\n28. stack(I, B)\n29. unstack(I, B)\n30. putdown(I)\n31. unstack(J, D)\n32. putdown(J)\n33. pickup(J)\n34. stack(J, K)\n35. unstack(M, F)\n36. stack(M, B)\n37. pickup(F)\n38. stack(F, D)\n39. unstack(M, B)\n40. stack(M, N)\n41. unstack(M, N)\n42. stack(M, J)\n43. pickup(N)\n44. stack(N, F)\n45. pickup(I)\n46. stack(I, N)\n47. unstack(I, N)\n48. stack(I, M)\n49. unstack(B, C)\n50. stack(B, I)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of B, B is on top of J, C is on top of I, D is on top of G, E is on the table, F is on the table, G is on top of E, H is on top of L, I is on top of N, J is on top of D, K is on top of H, L is on the table, M is on top of F, N is on the table. The agents then execute the following actions in order:\n1. unstack(A, B)\n2. putdown(A)\n3. unstack(K, H)\n4. putdown(K)\n5. unstack(C, I)\n6. stack(C, M)\n7. pickup(A)\n8. stack(A, I)\n9. unstack(A, I)\n10. stack(A, H)\n11. unstack(B, J)\n12. stack(B, I)\n13. unstack(C, M)\n14. stack(C, M)\n15. unstack(C, M)\n16. stack(C, A)\n17. pickup(K)\n18. stack(K, J)\n19. unstack(M, F)\n20. putdown(M)\n21. pickup(M)\n22. stack(M, F)\n23. unstack(B, I)\n24. stack(B, C)\n25. unstack(K, J)\n26. putdown(K)\n27. unstack(I, N)\n28. stack(I, B)\n29. unstack(I, B)\n30. putdown(I)\n31. unstack(J, D)\n32. putdown(J)\n33. pickup(J)\n34. stack(J, K)\n35. unstack(M, F)\n36. stack(M, B)\n37. pickup(F)\n38. stack(F, D)\n39. unstack(M, B)\n40. stack(M, N)\n41. unstack(M, N)\n42. stack(M, J)\n43. pickup(N)\n44. stack(N, F)\n45. pickup(I)\n46. stack(I, N)\n47. unstack(I, N)\n48. stack(I, M)\n49. unstack(B, C)\n50. stack(B, I)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of H, B is on top of I, C is on top of A, D is on top of G, E is on the table, F is on top of D, G is on top of E, H is on top of L, I is on top of M, J is on top of K, K is on the table, L is on the table, M is on top of J, N is on top of F",
    "response": "Final positions (each block: what it is directly on):\n\nA \u2014 on H\nB \u2014 on I\nC \u2014 on A\nD \u2014 on G\nE \u2014 on the table\nF \u2014 on D\nG \u2014 on E\nH \u2014 on L\nI \u2014 on M\nJ \u2014 on K\nK \u2014 on the table\nL \u2014 on the table\nM \u2014 on J\nN \u2014 on F\n\n(Stacks bottom\u2192top: [E, G, D, F, N], [L, H, A, C], [K, J, M, I, B])"
  },
  "blocksworld_50_instance_15": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on top of C, B is on the table, C is on top of E, D is on top of I, E is on the table, F is on top of D, G is on top of B, H is on top of A, I is on top of G, J is on the table. The agents then execute the following actions in order:\n1. unstack(F, D)\n2. stack(F, H)\n3. unstack(F, H)\n4. putdown(F)\n5. pickup(F)\n6. stack(F, J)\n7. unstack(D, I)\n8. stack(D, H)\n9. unstack(F, J)\n10. stack(F, J)\n11. unstack(D, H)\n12. stack(D, H)\n13. unstack(I, G)\n14. stack(I, G)\n15. unstack(D, H)\n16. putdown(D)\n17. unstack(F, J)\n18. stack(F, D)\n19. unstack(F, D)\n20. putdown(F)\n21. pickup(D)\n22. putdown(D)\n23. unstack(I, G)\n24. stack(I, G)\n25. pickup(J)\n26. stack(J, F)\n27. unstack(I, G)\n28. stack(I, G)\n29. pickup(D)\n30. stack(D, J)\n31. unstack(D, J)\n32. putdown(D)\n33. unstack(H, A)\n34. putdown(H)\n35. pickup(H)\n36. stack(H, J)\n37. unstack(A, C)\n38. putdown(A)\n39. unstack(I, G)\n40. stack(I, C)\n41. pickup(A)\n42. stack(A, G)\n43. unstack(H, J)\n44. stack(H, J)\n45. unstack(A, G)\n46. stack(A, G)\n47. unstack(I, C)\n48. stack(I, H)\n49. unstack(C, E)\n50. stack(C, I)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on top of C, B is on the table, C is on top of E, D is on top of I, E is on the table, F is on top of D, G is on top of B, H is on top of A, I is on top of G, J is on the table. The agents then execute the following actions in order:\n1. unstack(F, D)\n2. stack(F, H)\n3. unstack(F, H)\n4. putdown(F)\n5. pickup(F)\n6. stack(F, J)\n7. unstack(D, I)\n8. stack(D, H)\n9. unstack(F, J)\n10. stack(F, J)\n11. unstack(D, H)\n12. stack(D, H)\n13. unstack(I, G)\n14. stack(I, G)\n15. unstack(D, H)\n16. putdown(D)\n17. unstack(F, J)\n18. stack(F, D)\n19. unstack(F, D)\n20. putdown(F)\n21. pickup(D)\n22. putdown(D)\n23. unstack(I, G)\n24. stack(I, G)\n25. pickup(J)\n26. stack(J, F)\n27. unstack(I, G)\n28. stack(I, G)\n29. pickup(D)\n30. stack(D, J)\n31. unstack(D, J)\n32. putdown(D)\n33. unstack(H, A)\n34. putdown(H)\n35. pickup(H)\n36. stack(H, J)\n37. unstack(A, C)\n38. putdown(A)\n39. unstack(I, G)\n40. stack(I, C)\n41. pickup(A)\n42. stack(A, G)\n43. unstack(H, J)\n44. stack(H, J)\n45. unstack(A, G)\n46. stack(A, G)\n47. unstack(I, C)\n48. stack(I, H)\n49. unstack(C, E)\n50. stack(C, I)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of G, B is on the table, C is on top of I, D is on the table, E is on the table, F is on the table, G is on top of B, H is on top of J, I is on top of H, J is on top of F",
    "response": "Final configuration (each block listed with what it is on):\n\n- A is on G\n- B is on the table\n- C is on I\n- D is on the table\n- E is on the table\n- F is on the table\n- G is on B\n- H is on J\n- I is on H\n- J is on F\n\nEquivalently, the table stacks (bottom \u2192 top) are:\n- [E]\n- [B, G, A]\n- [F, J, H, I, C]\n- [D]"
  },
  "blocksworld_50_instance_16": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L. The initial arrangement is: A is on the table, B is on top of H, C is on top of B, D is on top of E, E is on top of L, F is on the table, G is on top of I, H is on the table, I is on top of F, J is on top of G, K is on top of A, L is on top of C. The agents then execute the following actions in order:\n1. unstack(D, E)\n2. stack(D, E)\n3. unstack(K, A)\n4. stack(K, J)\n5. unstack(K, J)\n6. stack(K, D)\n7. unstack(J, G)\n8. stack(J, A)\n9. unstack(K, D)\n10. stack(K, D)\n11. unstack(J, A)\n12. putdown(J)\n13. unstack(K, D)\n14. putdown(K)\n15. pickup(K)\n16. stack(K, A)\n17. unstack(G, I)\n18. stack(G, K)\n19. pickup(J)\n20. stack(J, G)\n21. unstack(D, E)\n22. stack(D, J)\n23. unstack(E, L)\n24. stack(E, D)\n25. unstack(I, F)\n26. putdown(I)\n27. pickup(I)\n28. stack(I, F)\n29. unstack(E, D)\n30. stack(E, L)\n31. unstack(E, L)\n32. stack(E, D)\n33. unstack(I, F)\n34. stack(I, E)\n35. unstack(L, C)\n36. stack(L, I)\n37. pickup(F)\n38. putdown(F)\n39. pickup(F)\n40. stack(F, C)\n41. unstack(F, C)\n42. putdown(F)\n43. unstack(L, I)\n44. stack(L, I)\n45. pickup(F)\n46. putdown(F)\n47. pickup(F)\n48. stack(F, L)\n49. unstack(F, L)\n50. stack(F, C)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L. The initial arrangement is: A is on the table, B is on top of H, C is on top of B, D is on top of E, E is on top of L, F is on the table, G is on top of I, H is on the table, I is on top of F, J is on top of G, K is on top of A, L is on top of C. The agents then execute the following actions in order:\n1. unstack(D, E)\n2. stack(D, E)\n3. unstack(K, A)\n4. stack(K, J)\n5. unstack(K, J)\n6. stack(K, D)\n7. unstack(J, G)\n8. stack(J, A)\n9. unstack(K, D)\n10. stack(K, D)\n11. unstack(J, A)\n12. putdown(J)\n13. unstack(K, D)\n14. putdown(K)\n15. pickup(K)\n16. stack(K, A)\n17. unstack(G, I)\n18. stack(G, K)\n19. pickup(J)\n20. stack(J, G)\n21. unstack(D, E)\n22. stack(D, J)\n23. unstack(E, L)\n24. stack(E, D)\n25. unstack(I, F)\n26. putdown(I)\n27. pickup(I)\n28. stack(I, F)\n29. unstack(E, D)\n30. stack(E, L)\n31. unstack(E, L)\n32. stack(E, D)\n33. unstack(I, F)\n34. stack(I, E)\n35. unstack(L, C)\n36. stack(L, I)\n37. pickup(F)\n38. putdown(F)\n39. pickup(F)\n40. stack(F, C)\n41. unstack(F, C)\n42. putdown(F)\n43. unstack(L, I)\n44. stack(L, I)\n45. pickup(F)\n46. putdown(F)\n47. pickup(F)\n48. stack(F, L)\n49. unstack(F, L)\n50. stack(F, C)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on top of H, C is on top of B, D is on top of J, E is on top of D, F is on top of C, G is on top of K, H is on the table, I is on top of E, J is on top of G, K is on top of A, L is on top of I",
    "response": "Final stacks (bottom -> top):\n\n- Stack 1: A - K - G - J - D - E - I - L\n- Stack 2: H - B - C - F\n\nThus, for each block:\n\n- A is on the table.\n- K is on A.\n- G is on K.\n- J is on G.\n- D is on J.\n- E is on D.\n- I is on E.\n- L is on I.\n- H is on the table.\n- B is on H.\n- C is on B.\n- F is on C."
  },
  "blocksworld_50_instance_17": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of N, B is on top of M, C is on top of B, D is on top of L, E is on top of A, F is on the table, G is on the table, H is on top of E, I is on top of C, J is on top of H, K is on top of D, L is on top of I, M is on top of G, N is on top of F. The agents then execute the following actions in order:\n1. unstack(K, D)\n2. stack(K, D)\n3. unstack(K, D)\n4. putdown(K)\n5. unstack(J, H)\n6. stack(J, D)\n7. unstack(J, D)\n8. stack(J, K)\n9. unstack(H, E)\n10. putdown(H)\n11. unstack(J, K)\n12. stack(J, H)\n13. unstack(D, L)\n14. putdown(D)\n15. unstack(L, I)\n16. stack(L, I)\n17. unstack(J, H)\n18. stack(J, D)\n19. unstack(L, I)\n20. putdown(L)\n21. pickup(L)\n22. stack(L, E)\n23. unstack(I, C)\n24. stack(I, L)\n25. pickup(H)\n26. stack(H, J)\n27. unstack(I, L)\n28. stack(I, H)\n29. unstack(C, B)\n30. stack(C, L)\n31. unstack(B, M)\n32. stack(B, K)\n33. unstack(M, G)\n34. stack(M, G)\n35. unstack(B, K)\n36. stack(B, K)\n37. unstack(M, G)\n38. stack(M, G)\n39. unstack(I, H)\n40. stack(I, B)\n41. unstack(I, B)\n42. stack(I, M)\n43. unstack(C, L)\n44. putdown(C)\n45. unstack(B, K)\n46. stack(B, L)\n47. unstack(H, J)\n48. stack(H, B)\n49. unstack(J, D)\n50. stack(J, K)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of N, B is on top of M, C is on top of B, D is on top of L, E is on top of A, F is on the table, G is on the table, H is on top of E, I is on top of C, J is on top of H, K is on top of D, L is on top of I, M is on top of G, N is on top of F. The agents then execute the following actions in order:\n1. unstack(K, D)\n2. stack(K, D)\n3. unstack(K, D)\n4. putdown(K)\n5. unstack(J, H)\n6. stack(J, D)\n7. unstack(J, D)\n8. stack(J, K)\n9. unstack(H, E)\n10. putdown(H)\n11. unstack(J, K)\n12. stack(J, H)\n13. unstack(D, L)\n14. putdown(D)\n15. unstack(L, I)\n16. stack(L, I)\n17. unstack(J, H)\n18. stack(J, D)\n19. unstack(L, I)\n20. putdown(L)\n21. pickup(L)\n22. stack(L, E)\n23. unstack(I, C)\n24. stack(I, L)\n25. pickup(H)\n26. stack(H, J)\n27. unstack(I, L)\n28. stack(I, H)\n29. unstack(C, B)\n30. stack(C, L)\n31. unstack(B, M)\n32. stack(B, K)\n33. unstack(M, G)\n34. stack(M, G)\n35. unstack(B, K)\n36. stack(B, K)\n37. unstack(M, G)\n38. stack(M, G)\n39. unstack(I, H)\n40. stack(I, B)\n41. unstack(I, B)\n42. stack(I, M)\n43. unstack(C, L)\n44. putdown(C)\n45. unstack(B, K)\n46. stack(B, L)\n47. unstack(H, J)\n48. stack(H, B)\n49. unstack(J, D)\n50. stack(J, K)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of N, B is on top of L, C is on the table, D is on the table, E is on top of A, F is on the table, G is on the table, H is on top of B, I is on top of M, J is on top of K, K is on the table, L is on top of E, M is on top of G, N is on top of F",
    "response": "Final stacks (bottom \u2192 top):\n- F - N - A - E - L - B - H\n- G - M - I\n- K - J\n- D\n- C\n\nSo for each block:\n- A is on N\n- B is on L\n- C is on the table\n- D is on the table\n- E is on A\n- F is on the table\n- G is on the table\n- H is on B\n- I is on M\n- J is on K\n- K is on the table\n- L is on E\n- M is on G\n- N is on F"
  },
  "blocksworld_50_instance_18": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on the table, B is on top of A, C is on top of B, D is on the table, E is on top of J, F is on the table, G is on top of H, H is on top of F, I is on top of D, J is on top of I. The agents then execute the following actions in order:\n1. unstack(E, J)\n2. stack(E, G)\n3. unstack(C, B)\n4. stack(C, B)\n5. unstack(C, B)\n6. stack(C, B)\n7. unstack(C, B)\n8. stack(C, B)\n9. unstack(J, I)\n10. stack(J, I)\n11. unstack(E, G)\n12. stack(E, C)\n13. unstack(G, H)\n14. putdown(G)\n15. unstack(J, I)\n16. stack(J, G)\n17. unstack(H, F)\n18. putdown(H)\n19. unstack(I, D)\n20. stack(I, H)\n21. pickup(D)\n22. stack(D, F)\n23. unstack(J, G)\n24. stack(J, I)\n25. unstack(E, C)\n26. stack(E, G)\n27. unstack(J, I)\n28. stack(J, D)\n29. unstack(I, H)\n30. stack(I, C)\n31. pickup(H)\n32. putdown(H)\n33. unstack(I, C)\n34. stack(I, J)\n35. unstack(I, J)\n36. putdown(I)\n37. pickup(I)\n38. putdown(I)\n39. unstack(J, D)\n40. stack(J, H)\n41. pickup(I)\n42. stack(I, C)\n43. unstack(D, F)\n44. stack(D, J)\n45. unstack(D, J)\n46. stack(D, E)\n47. unstack(J, H)\n48. stack(J, D)\n49. pickup(H)\n50. stack(H, J)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J. The initial arrangement is: A is on the table, B is on top of A, C is on top of B, D is on the table, E is on top of J, F is on the table, G is on top of H, H is on top of F, I is on top of D, J is on top of I. The agents then execute the following actions in order:\n1. unstack(E, J)\n2. stack(E, G)\n3. unstack(C, B)\n4. stack(C, B)\n5. unstack(C, B)\n6. stack(C, B)\n7. unstack(C, B)\n8. stack(C, B)\n9. unstack(J, I)\n10. stack(J, I)\n11. unstack(E, G)\n12. stack(E, C)\n13. unstack(G, H)\n14. putdown(G)\n15. unstack(J, I)\n16. stack(J, G)\n17. unstack(H, F)\n18. putdown(H)\n19. unstack(I, D)\n20. stack(I, H)\n21. pickup(D)\n22. stack(D, F)\n23. unstack(J, G)\n24. stack(J, I)\n25. unstack(E, C)\n26. stack(E, G)\n27. unstack(J, I)\n28. stack(J, D)\n29. unstack(I, H)\n30. stack(I, C)\n31. pickup(H)\n32. putdown(H)\n33. unstack(I, C)\n34. stack(I, J)\n35. unstack(I, J)\n36. putdown(I)\n37. pickup(I)\n38. putdown(I)\n39. unstack(J, D)\n40. stack(J, H)\n41. pickup(I)\n42. stack(I, C)\n43. unstack(D, F)\n44. stack(D, J)\n45. unstack(D, J)\n46. stack(D, E)\n47. unstack(J, H)\n48. stack(J, D)\n49. pickup(H)\n50. stack(H, J)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on the table, B is on top of A, C is on top of B, D is on top of E, E is on top of G, F is on the table, G is on the table, H is on top of J, I is on top of C, J is on top of D",
    "response": "Final stacks (bottom -> top):\n- A - B - C - I\n- F\n- G - E - D - J - H\n\nSo, for each block:\n- A: on the table\n- B: on A\n- C: on B\n- I: on C\n- F: on the table\n- G: on the table\n- E: on G\n- D: on E\n- J: on D\n- H: on J"
  },
  "blocksworld_50_instance_19": {
    "prompt_0shot": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of H, B is on top of F, C is on the table, D is on top of C, E is on top of J, F is on top of L, G is on top of D, H is on the table, I is on top of N, J is on top of K, K is on top of A, L is on top of E, M is on top of G, N is on top of M. The agents then execute the following actions in order:\n1. unstack(I, N)\n2. stack(I, N)\n3. unstack(B, F)\n4. stack(B, I)\n5. unstack(F, L)\n6. stack(F, B)\n7. unstack(F, B)\n8. stack(F, B)\n9. unstack(F, B)\n10. stack(F, B)\n11. unstack(L, E)\n12. stack(L, F)\n13. unstack(E, J)\n14. stack(E, L)\n15. unstack(E, L)\n16. stack(E, J)\n17. unstack(E, J)\n18. stack(E, L)\n19. unstack(J, K)\n20. stack(J, E)\n21. unstack(J, E)\n22. stack(J, K)\n23. unstack(E, L)\n24. stack(E, L)\n25. unstack(E, L)\n26. putdown(E)\n27. unstack(L, F)\n28. stack(L, J)\n29. unstack(L, J)\n30. stack(L, J)\n31. pickup(E)\n32. putdown(E)\n33. unstack(L, J)\n34. stack(L, E)\n35. unstack(L, E)\n36. stack(L, J)\n37. pickup(E)\n38. stack(E, L)\n39. unstack(E, L)\n40. stack(E, F)\n41. unstack(E, F)\n42. stack(E, F)\n43. unstack(L, J)\n44. stack(L, E)\n45. unstack(J, K)\n46. stack(J, L)\n47. unstack(K, A)\n48. stack(K, J)\n49. unstack(A, H)\n50. stack(A, H)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "prompt": "Two agents manipulate labelled blocks on a table following standard BlocksWorld rules: only the top block of a stack can be moved and only one block can be carried at a time. The blocks involved are A, B, C, D, E, F, G, H, I, J, K, L, M, N. The initial arrangement is: A is on top of H, B is on top of F, C is on the table, D is on top of C, E is on top of J, F is on top of L, G is on top of D, H is on the table, I is on top of N, J is on top of K, K is on top of A, L is on top of E, M is on top of G, N is on top of M. The agents then execute the following actions in order:\n1. unstack(I, N)\n2. stack(I, N)\n3. unstack(B, F)\n4. stack(B, I)\n5. unstack(F, L)\n6. stack(F, B)\n7. unstack(F, B)\n8. stack(F, B)\n9. unstack(F, B)\n10. stack(F, B)\n11. unstack(L, E)\n12. stack(L, F)\n13. unstack(E, J)\n14. stack(E, L)\n15. unstack(E, L)\n16. stack(E, J)\n17. unstack(E, J)\n18. stack(E, L)\n19. unstack(J, K)\n20. stack(J, E)\n21. unstack(J, E)\n22. stack(J, K)\n23. unstack(E, L)\n24. stack(E, L)\n25. unstack(E, L)\n26. putdown(E)\n27. unstack(L, F)\n28. stack(L, J)\n29. unstack(L, J)\n30. stack(L, J)\n31. pickup(E)\n32. putdown(E)\n33. unstack(L, J)\n34. stack(L, E)\n35. unstack(L, E)\n36. stack(L, J)\n37. pickup(E)\n38. stack(E, L)\n39. unstack(E, L)\n40. stack(E, F)\n41. unstack(E, F)\n42. stack(E, F)\n43. unstack(L, J)\n44. stack(L, E)\n45. unstack(J, K)\n46. stack(J, L)\n47. unstack(K, A)\n48. stack(K, J)\n49. unstack(A, H)\n50. stack(A, H)\nUsing the initial configuration and the actions, derive the final arrangement of the blocks. State for each block whether it is on the table or on top of another block.",
    "golden_plan": "A is on top of H, B is on top of I, C is on the table, D is on top of C, E is on top of F, F is on top of B, G is on top of D, H is on the table, I is on top of N, J is on top of L, K is on top of J, L is on top of E, M is on top of G, N is on top of M",
    "response": "Final configuration (each block: \"on X\" or \"on table\"):\n\n- A on H\n- B on I\n- C on table\n- D on C\n- E on F\n- F on B\n- G on D\n- H on table\n- I on N\n- J on L\n- K on J\n- L on E\n- M on G\n- N on M\n\nSo the two stacks (bottom \u2192 top) are:\n- H \u2192 A\n- C \u2192 D \u2192 G \u2192 M \u2192 N \u2192 I \u2192 B \u2192 F \u2192 E \u2192 L \u2192 J \u2192 K"
  }
}