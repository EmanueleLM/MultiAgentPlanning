PROBLEM
------------------------------
Solve a Tower of Hanoi puzzle using three pegs named left, middle, and right. There are 4 disks labelled A, B, C, D from smallest (A) to largest (D). Move one disk at a time and never place a larger disk on top of a smaller one. Initially, left peg has (top→bottom) A, B, C, D; middle peg is empty; right peg is empty. The goal configuration is: left peg is empty; middle peg is empty; right peg has (top→bottom) A, B, C, D.
================================================================================


ENVIRONMENT
------------------------------
Solve a Tower of Hanoi puzzle using three pegs named left, middle, and right. There are 4 disks labelled A, B, C, D from smallest (A) to largest (D). Move one disk at a time and never place a larger disk on top of a smaller one. Initially, left peg has (top→bottom) A, B, C, D; middle peg is empty; right peg is empty. The goal configuration is: left peg is empty; middle peg is empty; right peg has (top→bottom) A, B, C, D.
================================================================================


FINAL-PLAN
------------------------------
<domain>
(define (domain hanoi)
  (:requirements :strips :typing :negative-preconditions)
  (:types disk peg)

  (:predicates
    (on-peg ?d - disk ?p - peg)        ; disk is directly on peg
    (on-disk ?d - disk ?under - disk) ; disk is directly on another disk
    (top ?d - disk ?p - peg)          ; disk is the top disk of peg
    (empty ?p - peg)                  ; peg is empty (no disks)
    (clear ?d - disk)                 ; no disk on top of this disk
    (smaller ?a - disk ?b - disk)     ; a is smaller than b
  )

  ; Moves where the moving disk is directly on a peg and destination is empty
  (:action move-left-to-middle-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-left-to-right-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-left-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-right-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-left-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-middle-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  ; Moves where the moving disk is directly on a peg and destination has a top disk
  (:action move-left-to-middle-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-left-to-right-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-left-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-right-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-left-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-middle-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  ; Moves where the moving disk is on another disk and destination is empty
  (:action move-left-to-middle-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-left-to-right-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-left-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-right-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-left-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-middle-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  ; Moves where the moving disk is on another disk and destination has a top disk
  (:action move-left-to-middle-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-left-to-right-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-left-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-right-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-left-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-middle-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

)
</domain>

<problem>
(define (problem hanoi-4)
  (:domain hanoi)
  (:objects
    left middle right - peg
    A B C D - disk
  )

  (:init
    ; initial stack on left (top -> bottom): A B C D
    (on-disk A B)
    (on-disk B C)
    (on-disk C D)
    (on-peg D left)
    (top A left)
    (empty middle)
    (empty right)
    (clear A)
    ; B, C, D are not clear initially (there are disks on top of them) -- we do not assert their negations using predicates,
    ; but clear for those is simply absent
    ; size ordering (A smallest, D largest)
    (smaller A B) (smaller A C) (smaller A D)
    (smaller B C) (smaller B D)
    (smaller C D)
  )

  (:goal (and
    ; goal: right peg has stack top->bottom A B C D and other pegs empty
    (on-disk A B)
    (on-disk B C)
    (on-disk C D)
    (on-peg D right)
    (top A right)
    (empty left)
    (empty middle)
  ))
)
</problem>
================================================================================


DOMAIN
------------------------------
(define (domain hanoi)
  (:requirements :strips :typing :negative-preconditions)
  (:types disk peg)

  (:predicates
    (on-peg ?d - disk ?p - peg)        ; disk is directly on peg
    (on-disk ?d - disk ?under - disk) ; disk is directly on another disk
    (top ?d - disk ?p - peg)          ; disk is the top disk of peg
    (empty ?p - peg)                  ; peg is empty (no disks)
    (clear ?d - disk)                 ; no disk on top of this disk
    (smaller ?a - disk ?b - disk)     ; a is smaller than b
  )

  ; Moves where the moving disk is directly on a peg and destination is empty
  (:action move-left-to-middle-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-left-to-right-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-left-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-right-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-left-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-middle-frompeg-to-empty
    :parameters (?d - disk ?src - peg ?dst - peg)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  ; Moves where the moving disk is directly on a peg and destination has a top disk
  (:action move-left-to-middle-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-left-to-right-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-left-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-middle-to-right-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-left-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  (:action move-right-to-middle-frompeg-to-stack
    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-peg ?d ?src)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-peg ?d ?src))
      (not (top ?d ?src))
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
      (empty ?src)
    )
  )

  ; Moves where the moving disk is on another disk and destination is empty
  (:action move-left-to-middle-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-left-to-right-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-left-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-right-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-left-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-middle-fromdisk-to-empty
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (empty ?dst)
      (clear ?d)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (empty ?dst))
      (on-peg ?d ?dst)
      (top ?d ?dst)
    )
  )

  ; Moves where the moving disk is on another disk and destination has a top disk
  (:action move-left-to-middle-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-left-to-right-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src left) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-left-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-middle-to-right-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src middle) (= ?dst right)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-left-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst left)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

  (:action move-right-to-middle-fromdisk-to-stack
    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)
    :precondition (and
      (on-disk ?d ?under)
      (top ?d ?src)
      (top ?dsttop ?dst)
      (clear ?d)
      (smaller ?d ?dsttop)
      (= ?src right) (= ?dst middle)
    )
    :effect (and
      (not (on-disk ?d ?under))
      (not (top ?d ?src))
      (top ?under ?src)
      (clear ?under)
      (not (top ?dsttop ?dst))
      (not (clear ?dsttop))
      (on-disk ?d ?dsttop)
      (top ?d ?dst)
    )
  )

)
================================================================================


PROBLEM
------------------------------
(define (problem hanoi-4)
  (:domain hanoi)
  (:objects
    left middle right - peg
    A B C D - disk
  )

  (:init
    ; initial stack on left (top -> bottom): A B C D
    (on-disk A B)
    (on-disk B C)
    (on-disk C D)
    (on-peg D left)
    (top A left)
    (empty middle)
    (empty right)
    (clear A)
    ; B, C, D are not clear initially (there are disks on top of them) -- we do not assert their negations using predicates,
    ; but clear for those is simply absent
    ; size ordering (A smallest, D largest)
    (smaller A B) (smaller A C) (smaller A D)
    (smaller B C) (smaller B D)
    (smaller C D)
  )

  (:goal (and
    ; goal: right peg has stack top->bottom A B C D and other pegs empty
    (on-disk A B)
    (on-disk B C)
    (on-disk C D)
    (on-peg D right)
    (top A right)
    (empty left)
    (empty middle)
  ))
)
================================================================================


ITERATION 0
------------------------------
{
    "human_specification": "Solve a Tower of Hanoi puzzle using three pegs named left, middle, and right. There are 4 disks labelled A, B, C, D from smallest (A) to largest (D). Move one disk at a time and never place a larger disk on top of a smaller one. Initially, left peg has (top\u2192bottom) A, B, C, D; middle peg is empty; right peg is empty. The goal configuration is: left peg is empty; middle peg is empty; right peg has (top\u2192bottom) A, B, C, D.",
    "plan": "No plan yet.",
    "specification": {
        "name": "Hanoi4Instance0",
        "author": "Human",
        "agents": {
            "number": 4,
            "names": [
                "left_peg",
                "middle_peg",
                "right_peg",
                "orchestrator"
            ],
            "left_peg": {
                "private_information": [
                    "I am responsible for the left peg",
                    "Initial stack top\u2192bottom: A B C D",
                    "I can move the top disk to another peg if that move obeys the rules"
                ],
                "goal": "Help move all disks to the right peg so it has top\u2192bottom A B C D"
            },
            "middle_peg": {
                "private_information": [
                    "I am responsible for the middle peg",
                    "Initial stack is empty",
                    "I can receive or send the top disk if moves obey the rules"
                ],
                "goal": "Support intermediate moves to enable final configuration on the right peg"
            },
            "right_peg": {
                "private_information": [
                    "I am responsible for the right peg",
                    "Initial stack is empty",
                    "I will be the target peg for the final stacking of disks"
                ],
                "goal": "Receive all disks so the final stack is top\u2192bottom A B C D"
            },
            "orchestrator": {
                "private_information": [],
                "goal": "Produce a global PDDL domain and problem for FastDownwards to move 4 disks from left to right under the standard Tower of Hanoi rules"
            }
        },
        "environment": {
            "init": {
                "num_disks": 4,
                "pegs": [
                    "left",
                    "middle",
                    "right"
                ],
                "disk_labels": [
                    "A",
                    "B",
                    "C",
                    "D"
                ],
                "initial_configuration": {
                    "left": [
                        "A",
                        "B",
                        "C",
                        "D"
                    ],
                    "middle": [],
                    "right": []
                }
            },
            "public_information": [
                "There are three pegs named left middle and right",
                "There are four disks labeled A B C D with A smallest and D largest",
                "Only one disk can be moved at a time and a larger disk cannot be placed on top of a smaller disk",
                "Initial configuration is left peg has top to bottom A B C D and other pegs are empty",
                "Goal is right peg has top to bottom A B C D and other pegs are empty"
            ]
        },
        "workflow": {
            "left_peg": {
                "report": {
                    "input": [],
                    "output": "report_left",
                    "system_prompt": "You represent the left peg and should not produce PDDL. Provide a concise description of your local state, the top disk you control, and the immediate legal moves from your perspective.",
                    "prompt": "Your name is left_peg. Use your private information {agents->left_peg->private_information} and the environment public information {environment->public_information} to describe the left peg state and the legal top-disk moves you can perform. Do not produce PDDL."
                }
            },
            "middle_peg": {
                "report": {
                    "input": [],
                    "output": "report_middle",
                    "system_prompt": "You represent the middle peg and should not produce PDDL. Provide a concise description of your local state, the top disk if any, and the immediate legal moves from your perspective.",
                    "prompt": "Your name is middle_peg. Use your private information {agents->middle_peg->private_information} and the environment public information {environment->public_information} to describe the middle peg state and the legal top-disk moves you can perform. Do not produce PDDL."
                }
            },
            "right_peg": {
                "report": {
                    "input": [],
                    "output": "report_right",
                    "system_prompt": "You represent the right peg and should not produce PDDL. Provide a concise description of your local state, the top disk if any, and the immediate legal moves from your perspective.",
                    "prompt": "Your name is right_peg. Use your private information {agents->right_peg->private_information} and the environment public information {environment->public_information} to describe the right peg state and the legal top-disk moves you can perform. Do not produce PDDL."
                }
            },
            "orchestrator": {
                "pddl": {
                    "input": [
                        "report_left",
                        "report_middle",
                        "report_right"
                    ],
                    "output": "pddl_orchestrator",
                    "system_prompt": "You are an expert in PDDL modeling and planning for the FastDownwards solver. Produce a complete PDDL domain and a PDDL problem that model the Tower of Hanoi instance described. Enclose the PDDL domain between <domain></domain> tags and the PDDL problem between <problem></problem> tags. Ensure actions are distinct for agents where appropriate, enforce single-disk moves, and enforce that a larger disk cannot be placed on a smaller disk. Target syntax and constructs compatible with FastDownwards.",
                    "prompt": "You are the orchestrator. Integrate the peg reports {report_left} {report_middle} {report_right} with the public environment facts {environment->public_information} to produce a PDDL domain and a PDDL problem that achieve the orchestrator goal {agents->orchestrator->goal}. Think step by step and output the final PDDL domain and problem suitable for FastDownwards. Enclose the domain between <domain></domain> and the problem between <problem></problem>."
                }
            },
            "constraints": [
                "left_peg.report->orchestrator.pddl",
                "middle_peg.report->orchestrator.pddl",
                "right_peg.report->orchestrator.pddl"
            ]
        }
    },
    "pddl_domain": "(define (domain hanoi)\n  (:requirements :strips :typing :negative-preconditions)\n  (:types disk peg)\n\n  (:predicates\n    (on-peg ?d - disk ?p - peg)        ; disk is directly on peg\n    (on-disk ?d - disk ?under - disk) ; disk is directly on another disk\n    (top ?d - disk ?p - peg)          ; disk is the top disk of peg\n    (empty ?p - peg)                  ; peg is empty (no disks)\n    (clear ?d - disk)                 ; no disk on top of this disk\n    (smaller ?a - disk ?b - disk)     ; a is smaller than b\n  )\n\n  ; Moves where the moving disk is directly on a peg and destination is empty\n  (:action move-left-to-middle-frompeg-to-empty\n    :parameters (?d - disk ?src - peg ?dst - peg)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src left) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-left-to-right-frompeg-to-empty\n    :parameters (?d - disk ?src - peg ?dst - peg)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src left) (= ?dst right)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-middle-to-left-frompeg-to-empty\n    :parameters (?d - disk ?src - peg ?dst - peg)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src middle) (= ?dst left)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-middle-to-right-frompeg-to-empty\n    :parameters (?d - disk ?src - peg ?dst - peg)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src middle) (= ?dst right)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-right-to-left-frompeg-to-empty\n    :parameters (?d - disk ?src - peg ?dst - peg)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src right) (= ?dst left)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-right-to-middle-frompeg-to-empty\n    :parameters (?d - disk ?src - peg ?dst - peg)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src right) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  ; Moves where the moving disk is directly on a peg and destination has a top disk\n  (:action move-left-to-middle-frompeg-to-stack\n    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src left) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-left-to-right-frompeg-to-stack\n    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src left) (= ?dst right)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-middle-to-left-frompeg-to-stack\n    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src middle) (= ?dst left)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-middle-to-right-frompeg-to-stack\n    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src middle) (= ?dst right)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-right-to-left-frompeg-to-stack\n    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src right) (= ?dst left)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  (:action move-right-to-middle-frompeg-to-stack\n    :parameters (?d - disk ?src - peg ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-peg ?d ?src)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src right) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-peg ?d ?src))\n      (not (top ?d ?src))\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n      (empty ?src)\n    )\n  )\n\n  ; Moves where the moving disk is on another disk and destination is empty\n  (:action move-left-to-middle-fromdisk-to-empty\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src left) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-left-to-right-fromdisk-to-empty\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src left) (= ?dst right)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-middle-to-left-fromdisk-to-empty\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src middle) (= ?dst left)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-middle-to-right-fromdisk-to-empty\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src middle) (= ?dst right)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-right-to-left-fromdisk-to-empty\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src right) (= ?dst left)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-right-to-middle-fromdisk-to-empty\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (empty ?dst)\n      (clear ?d)\n      (= ?src right) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (empty ?dst))\n      (on-peg ?d ?dst)\n      (top ?d ?dst)\n    )\n  )\n\n  ; Moves where the moving disk is on another disk and destination has a top disk\n  (:action move-left-to-middle-fromdisk-to-stack\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src left) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-left-to-right-fromdisk-to-stack\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src left) (= ?dst right)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-middle-to-left-fromdisk-to-stack\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src middle) (= ?dst left)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-middle-to-right-fromdisk-to-stack\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src middle) (= ?dst right)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-right-to-left-fromdisk-to-stack\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src right) (= ?dst left)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n    )\n  )\n\n  (:action move-right-to-middle-fromdisk-to-stack\n    :parameters (?d - disk ?src - peg ?under - disk ?dst - peg ?dsttop - disk)\n    :precondition (and\n      (on-disk ?d ?under)\n      (top ?d ?src)\n      (top ?dsttop ?dst)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n      (= ?src right) (= ?dst middle)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?src))\n      (top ?under ?src)\n      (clear ?under)\n      (not (top ?dsttop ?dst))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?dst)\n    )\n  )\n\n)",
    "pddl_problem": "(define (problem hanoi-4)\n  (:domain hanoi)\n  (:objects\n    left middle right - peg\n    A B C D - disk\n  )\n\n  (:init\n    ; initial stack on left (top -> bottom): A B C D\n    (on-disk A B)\n    (on-disk B C)\n    (on-disk C D)\n    (on-peg D left)\n    (top A left)\n    (empty middle)\n    (empty right)\n    (clear A)\n    ; B, C, D are not clear initially (there are disks on top of them) -- we do not assert their negations using predicates,\n    ; but clear for those is simply absent\n    ; size ordering (A smallest, D largest)\n    (smaller A B) (smaller A C) (smaller A D)\n    (smaller B C) (smaller B D)\n    (smaller C D)\n  )\n\n  (:goal (and\n    ; goal: right peg has stack top->bottom A B C D and other pegs empty\n    (on-disk A B)\n    (on-disk B C)\n    (on-disk C D)\n    (on-peg D right)\n    (top A right)\n    (empty left)\n    (empty middle)\n  ))\n)",
    "target_solver": "FastDownwards",
    "pddl_plan": "(move-left-to-middle-fromdisk-to-empty a left b middle)\n(move-left-to-right-fromdisk-to-empty b left c right)\n(move-middle-to-right-frompeg-to-stack a middle right b)\n(move-left-to-middle-fromdisk-to-empty c left d middle)\n(move-right-to-left-fromdisk-to-stack a right b left d)\n(move-right-to-middle-frompeg-to-stack b right middle c)\n(move-left-to-middle-fromdisk-to-stack a left d middle b)\n(move-left-to-right-frompeg-to-empty d left right)\n(move-middle-to-right-fromdisk-to-stack a middle b right d)\n(move-middle-to-left-fromdisk-to-empty b middle c left)\n(move-right-to-left-fromdisk-to-stack a right d left b)\n(move-middle-to-right-frompeg-to-stack c middle right d)\n(move-left-to-middle-fromdisk-to-empty a left b middle)\n(move-left-to-right-frompeg-to-stack b left right c)\n(move-middle-to-right-frompeg-to-stack a middle right b)\n; cost = 15 (unit cost)\n",
    "syntax_errors": "terminate called after throwing an instance of 'parser::pddl::UnknownToken'\n  what():  LEFT does not name a known token\nAborted (core dumped)\n",
    "pddl_logs": "INFO     planner time limit: None\nINFO     planner memory limit: None\n\nINFO     Running translator.\nINFO     translator stdin: None\nINFO     translator time limit: None\nINFO     translator memory limit: None\nINFO     translator command line string: /home/emanuele/MultiAgentPlanning/.venv/bin/python3 /home/emanuele/MultiAgentPlanning/solvers/fast-downward-24.06.1/builds/release/bin/translate/translate.py results/hanoi_scaling/hanoi_4_disks/hanoi_4_disks/FastDownwards/Hanoi4Instance0/domain_0.pddl results/hanoi_scaling/hanoi_4_disks/hanoi_4_disks/FastDownwards/Hanoi4Instance0/problem_0.pddl --sas-file output.sas\nParsing...\nParsing: [0.010s CPU, 0.008s wall-clock]\nNormalizing task... [0.000s CPU, 0.001s wall-clock]\nInstantiating...\nGenerating Datalog program... [0.000s CPU, 0.001s wall-clock]\nNormalizing Datalog program...\nNormalizing Datalog program: [0.010s CPU, 0.011s wall-clock]\nPreparing model... [0.010s CPU, 0.004s wall-clock]\nGenerated 361 rules.\nComputing model... [0.010s CPU, 0.012s wall-clock]\n245 relevant atoms\n1200 auxiliary atoms\n1445 final queue length\n2076 total queue pushes\nCompleting instantiation... [0.010s CPU, 0.009s wall-clock]\nInstantiating: [0.040s CPU, 0.037s wall-clock]\nComputing fact groups...\nFinding invariants...\n13 initial candidates\nFinding invariants: [0.010s CPU, 0.017s wall-clock]\nChecking invariant weight... [0.000s CPU, 0.000s wall-clock]\nInstantiating groups... [0.000s CPU, 0.000s wall-clock]\nCollecting mutex groups... [0.000s CPU, 0.000s wall-clock]\nChoosing groups...\n4 uncovered facts\nChoosing groups: [0.000s CPU, 0.000s wall-clock]\nBuilding translation key... [0.000s CPU, 0.000s wall-clock]\nComputing fact groups: [0.010s CPU, 0.018s wall-clock]\nBuilding STRIPS to SAS dictionary... [0.000s CPU, 0.000s wall-clock]\nBuilding dictionary for full mutex groups... [0.000s CPU, 0.000s wall-clock]\nBuilding mutex information...\nBuilding mutex information: [0.000s CPU, 0.000s wall-clock]\nTranslating task...\nProcessing axioms...\nSimplifying axioms... [0.000s CPU, 0.000s wall-clock]\nTranslator axioms removed by simplifying: 0\nProcessing axioms: [0.010s CPU, 0.001s wall-clock]\nTranslating task: [0.010s CPU, 0.007s wall-clock]\n84 effect conditions simplified\n0 implied preconditions added\nDetecting unreachable propositions...\n0 operators removed\n0 axioms removed\n4 propositions removed\nDetecting unreachable propositions: [0.010s CPU, 0.003s wall-clock]\nReordering and filtering variables...\n11 of 11 variables necessary.\n12 of 14 mutex groups necessary.\n144 of 144 operators necessary.\n0 of 0 axiom rules necessary.\nReordering and filtering variables: [0.000s CPU, 0.002s wall-clock]\nTranslator variables: 11\nTranslator derived variables: 0\nTranslator facts: 45\nTranslator goal facts: 7\nTranslator mutex groups: 12\nTranslator total mutex groups size: 57\nTranslator operators: 144\nTranslator axioms: 0\nTranslator task size: 1440\nTranslator peak memory: 33828 KB\nWriting output... [0.000s CPU, 0.001s wall-clock]\nDone! [0.080s CPU, 0.078s wall-clock]\ntranslate exit code: 0\n\nINFO     Running search (release).\nINFO     search stdin: output.sas\nINFO     search time limit: None\nINFO     search memory limit: None\nINFO     search command line string: /home/emanuele/MultiAgentPlanning/solvers/fast-downward-24.06.1/builds/release/bin/downward --search 'let(hlm,landmark_sum(lm_factory=lm_reasonable_orders_hps(lm_rhw()),transform=adapt_costs(one),pref=false),let(hff,ff(transform=adapt_costs(one)),lazy_greedy([hff,hlm],preferred=[hff,hlm],cost_type=one,reopen_closed=false)))' --internal-plan-file results/hanoi_scaling/hanoi_4_disks/hanoi_4_disks/FastDownwards/Hanoi4Instance0/sas_plan_0 < output.sas\n[t=0.000256s, 9964 KB] reading input...\n[t=0.001417s, 9964 KB] done reading input!\n[t=0.003181s, 10360 KB] Initializing landmark sum heuristic...\n[t=0.003254s, 10360 KB] Generating landmark graph...\n[t=0.003310s, 10360 KB] Building a landmark graph with reasonable orders.\n[t=0.003356s, 10360 KB] Initializing Exploration...\n[t=0.003487s, 10360 KB] Generating landmarks using the RPG/SAS+ approach\n[t=0.004664s, 10360 KB] Landmarks generation time: 0.001359s\n[t=0.004702s, 10360 KB] Discovered 19 landmarks, of which 2 are disjunctive and 0 are conjunctive.\n[t=0.004722s, 10360 KB] 33 edges\n[t=0.004738s, 10360 KB] approx. reasonable orders\n[t=0.005487s, 10360 KB] Landmarks generation time: 0.002228s\n[t=0.005505s, 10360 KB] Discovered 19 landmarks, of which 2 are disjunctive and 0 are conjunctive.\n[t=0.005520s, 10360 KB] 41 edges\n[t=0.005534s, 10360 KB] Landmark graph generation time: 0.002293s\n[t=0.005549s, 10360 KB] Landmark graph contains 19 landmarks, of which 2 are disjunctive and 0 are conjunctive.\n[t=0.005563s, 10360 KB] Landmark graph contains 41 orderings.\n[t=0.005723s, 10360 KB] Simplifying 678 unary operators... done! [678 unary operators]\n[t=0.006318s, 10360 KB] time to simplify: 0.000636s\n[t=0.006407s, 10360 KB] Initializing additive heuristic...\n[t=0.006431s, 10360 KB] Initializing FF heuristic...\n[t=0.006490s, 10360 KB] Building successor generator...done!\n[t=0.006638s, 10360 KB] peak memory difference for successor generator creation: 0 KB\n[t=0.006653s, 10360 KB] time for successor generation creation: 0.000104s\n[t=0.006669s, 10360 KB] Variables: 11\n[t=0.006684s, 10360 KB] FactPairs: 45\n[t=0.006698s, 10360 KB] Bytes per state: 4\n[t=0.006742s, 10360 KB] Conducting lazy best first search, (real) bound = 2147483647\n[t=0.006809s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 10\n[t=0.006828s, 10360 KB] New best heuristic value for ff: 6\n[t=0.006842s, 10360 KB] g=0, 1 evaluated, 0 expanded\n[t=0.006863s, 10360 KB] Initial heuristic value for landmark_sum_heuristic: 10\n[t=0.006877s, 10360 KB] Initial heuristic value for ff: 6\n[t=0.006912s, 10360 KB] New best heuristic value for ff: 5\n[t=0.006927s, 10360 KB] g=1, 2 evaluated, 1 expanded\n[t=0.007005s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 8\n[t=0.007021s, 10360 KB] g=3, 5 evaluated, 4 expanded\n[t=0.007053s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 7\n[t=0.007068s, 10360 KB] g=4, 6 evaluated, 5 expanded\n[t=0.007175s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 5\n[t=0.007191s, 10360 KB] g=7, 11 evaluated, 10 expanded\n[t=0.007223s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 3\n[t=0.007238s, 10360 KB] g=8, 12 evaluated, 11 expanded\n[t=0.007268s, 10360 KB] New best heuristic value for ff: 4\n[t=0.007283s, 10360 KB] g=9, 13 evaluated, 12 expanded\n[t=0.007491s, 10360 KB] New best heuristic value for ff: 3\n[t=0.007506s, 10360 KB] g=13, 26 evaluated, 25 expanded\n[t=0.007531s, 10360 KB] New best heuristic value for ff: 2\n[t=0.007545s, 10360 KB] g=14, 27 evaluated, 26 expanded\n[t=0.007577s, 10360 KB] Solution found!\n[t=0.007592s, 10360 KB] Actual search time: 0.000831s\nmove-left-to-middle-fromdisk-to-empty a left b middle (1)\nmove-left-to-right-fromdisk-to-empty b left c right (1)\nmove-middle-to-right-frompeg-to-stack a middle right b (1)\nmove-left-to-middle-fromdisk-to-empty c left d middle (1)\nmove-right-to-left-fromdisk-to-stack a right b left d (1)\nmove-right-to-middle-frompeg-to-stack b right middle c (1)\nmove-left-to-middle-fromdisk-to-stack a left d middle b (1)\nmove-left-to-right-frompeg-to-empty d left right (1)\nmove-middle-to-right-fromdisk-to-stack a middle b right d (1)\nmove-middle-to-left-fromdisk-to-empty b middle c left (1)\nmove-right-to-left-fromdisk-to-stack a right d left b (1)\nmove-middle-to-right-frompeg-to-stack c middle right d (1)\nmove-left-to-middle-fromdisk-to-empty a left b middle (1)\nmove-left-to-right-frompeg-to-stack b left right c (1)\nmove-middle-to-right-frompeg-to-stack a middle right b (1)\n[t=0.007608s, 10360 KB] Plan length: 15 step(s).\n[t=0.007608s, 10360 KB] Plan cost: 15\n[t=0.007608s, 10360 KB] Expanded 28 state(s).\n[t=0.007608s, 10360 KB] Reopened 0 state(s).\n[t=0.007608s, 10360 KB] Evaluated 29 state(s).\n[t=0.007608s, 10360 KB] Evaluations: 58\n[t=0.007608s, 10360 KB] Generated 83 state(s).\n[t=0.007608s, 10360 KB] Dead ends: 0 state(s).\n[t=0.007608s, 10360 KB] Number of registered states: 29\n[t=0.007608s, 10360 KB] Int hash set load factor: 29/32 = 0.906250\n[t=0.007608s, 10360 KB] Int hash set resizes: 5\n[t=0.007608s, 10360 KB] Search time: 0.000867s\n[t=0.007608s, 10360 KB] Total time: 0.007608s\nSolution found.\nPeak memory: 10360 KB\nRemove intermediate file output.sas\nsearch exit code: 0\n\nINFO     Planner time: 0.19s\n",
    "history": [],
    "proposed_solution": ""
}
================================================================================


ITERATION 1
------------------------------
{
    "human_specification": "Solve a Tower of Hanoi puzzle using three pegs named left, middle, and right. There are 4 disks labelled A, B, C, D from smallest (A) to largest (D). Move one disk at a time and never place a larger disk on top of a smaller one. Initially, left peg has (top\u2192bottom) A, B, C, D; middle peg is empty; right peg is empty. The goal configuration is: left peg is empty; middle peg is empty; right peg has (top\u2192bottom) A, B, C, D.",
    "plan": "No plan yet.",
    "specification": {
        "name": "Hanoi4Instance0",
        "author": "Human",
        "agents": {
            "number": 4,
            "names": [
                "left_peg",
                "middle_peg",
                "right_peg",
                "orchestrator"
            ],
            "left_peg": {
                "private_information": [
                    "I am responsible for the left peg",
                    "Initial stack top\u2192bottom: A B C D",
                    "I can move the top disk to another peg if that move obeys the rules"
                ],
                "goal": "Help move all disks to the right peg so it has top\u2192bottom A B C D"
            },
            "middle_peg": {
                "private_information": [
                    "I am responsible for the middle peg",
                    "Initial stack is empty",
                    "I can receive or send the top disk if moves obey the rules"
                ],
                "goal": "Support intermediate moves to enable final configuration on the right peg"
            },
            "right_peg": {
                "private_information": [
                    "I am responsible for the right peg",
                    "Initial stack is empty",
                    "I will be the target peg for the final stacking of disks"
                ],
                "goal": "Receive all disks so the final stack is top\u2192bottom A B C D"
            },
            "orchestrator": {
                "private_information": [],
                "goal": "Produce a global PDDL domain and problem for FastDownwards to move 4 disks from left to right under the standard Tower of Hanoi rules"
            }
        },
        "environment": {
            "init": {
                "num_disks": 4,
                "pegs": [
                    "left",
                    "middle",
                    "right"
                ],
                "disk_labels": [
                    "A",
                    "B",
                    "C",
                    "D"
                ],
                "initial_configuration": {
                    "left": [
                        "A",
                        "B",
                        "C",
                        "D"
                    ],
                    "middle": [],
                    "right": []
                }
            },
            "public_information": [
                "There are three pegs named left middle and right",
                "There are four disks labeled A B C D with A smallest and D largest",
                "Only one disk can be moved at a time and a larger disk cannot be placed on top of a smaller disk",
                "Initial configuration is left peg has top to bottom A B C D and other pegs are empty",
                "Goal is right peg has top to bottom A B C D and other pegs are empty"
            ]
        },
        "workflow": {
            "left_peg": {
                "report": {
                    "input": [],
                    "output": "report_left",
                    "system_prompt": "You represent the left peg and should not produce PDDL. Provide a concise description of your local state, the top disk you control, and the immediate legal moves from your perspective.",
                    "prompt": "Your name is left_peg. Use your private information {agents->left_peg->private_information} and the environment public information {environment->public_information} to describe the left peg state and the legal top-disk moves you can perform. Do not produce PDDL."
                }
            },
            "middle_peg": {
                "report": {
                    "input": [],
                    "output": "report_middle",
                    "system_prompt": "You represent the middle peg and should not produce PDDL. Provide a concise description of your local state, the top disk if any, and the immediate legal moves from your perspective.",
                    "prompt": "Your name is middle_peg. Use your private information {agents->middle_peg->private_information} and the environment public information {environment->public_information} to describe the middle peg state and the legal top-disk moves you can perform. Do not produce PDDL."
                }
            },
            "right_peg": {
                "report": {
                    "input": [],
                    "output": "report_right",
                    "system_prompt": "You represent the right peg and should not produce PDDL. Provide a concise description of your local state, the top disk if any, and the immediate legal moves from your perspective.",
                    "prompt": "Your name is right_peg. Use your private information {agents->right_peg->private_information} and the environment public information {environment->public_information} to describe the right peg state and the legal top-disk moves you can perform. Do not produce PDDL."
                }
            },
            "orchestrator": {
                "pddl": {
                    "input": [
                        "report_left",
                        "report_middle",
                        "report_right"
                    ],
                    "output": "pddl_orchestrator",
                    "system_prompt": "You are an expert in PDDL modeling and planning for the FastDownwards solver. Produce a complete PDDL domain and a PDDL problem that model the Tower of Hanoi instance described. Enclose the PDDL domain between <domain></domain> tags and the PDDL problem between <problem></problem> tags. Ensure actions are distinct for agents where appropriate, enforce single-disk moves, and enforce that a larger disk cannot be placed on a smaller disk. Target syntax and constructs compatible with FastDownwards.",
                    "prompt": "You are the orchestrator. Integrate the peg reports {report_left} {report_middle} {report_right} with the public environment facts {environment->public_information} to produce a PDDL domain and a PDDL problem that achieve the orchestrator goal {agents->orchestrator->goal}. Think step by step and output the final PDDL domain and problem suitable for FastDownwards. Enclose the domain between <domain></domain> and the problem between <problem></problem>."
                }
            },
            "constraints": [
                "left_peg.report->orchestrator.pddl",
                "middle_peg.report->orchestrator.pddl",
                "right_peg.report->orchestrator.pddl"
            ]
        }
    },
    "pddl_domain": "(define (domain hanoi-4)\n  (:requirements :strips :typing :negative-preconditions)\n  (:types disk peg)\n\n  (:predicates\n    (on-peg ?d - disk ?p - peg)      ; disk ?d is directly on peg ?p\n    (on-disk ?d - disk ?under - disk) ; disk ?d is directly on disk ?under\n    (top ?d - disk ?p - peg)         ; disk ?d is the top disk on peg ?p\n    (empty ?p - peg)                 ; peg ?p is empty (no disks)\n    (clear ?d - disk)                ; no disk on top of disk ?d (it is clear)\n    (smaller ?a - disk ?b - disk)    ; disk ?a is smaller than disk ?b\n  )\n\n  ; Move when disk is directly on a peg and destination peg is empty\n  (:action move-peg-to-empty\n    :parameters (?d - disk ?from - peg ?to - peg)\n    :precondition (and\n      (top ?d ?from)\n      (on-peg ?d ?from)\n      (empty ?to)\n      (clear ?d)\n    )\n    :effect (and\n      (not (on-peg ?d ?from))\n      (not (top ?d ?from))\n      (not (empty ?to))\n      (on-peg ?d ?to)\n      (top ?d ?to)\n      (empty ?from)\n    )\n  )\n\n  ; Move when disk is directly on a peg and destination peg has a top disk\n  (:action move-peg-to-disk\n    :parameters (?d - disk ?from - peg ?to - peg ?dsttop - disk)\n    :precondition (and\n      (top ?d ?from)\n      (on-peg ?d ?from)\n      (top ?dsttop ?to)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n    )\n    :effect (and\n      (not (on-peg ?d ?from))\n      (not (top ?d ?from))\n      (not (top ?dsttop ?to))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?to)\n      (empty ?from)\n    )\n  )\n\n  ; Move when disk is on another disk and destination peg is empty\n  (:action move-disk-to-empty\n    :parameters (?d - disk ?under - disk ?from - peg ?to - peg)\n    :precondition (and\n      (top ?d ?from)\n      (on-disk ?d ?under)\n      (empty ?to)\n      (clear ?d)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?from))\n      (top ?under ?from)\n      (clear ?under)\n      (not (empty ?to))\n      (on-peg ?d ?to)\n      (top ?d ?to)\n    )\n  )\n\n  ; Move when disk is on another disk and destination peg has a top disk\n  (:action move-disk-to-disk\n    :parameters (?d - disk ?under - disk ?from - peg ?to - peg ?dsttop - disk)\n    :precondition (and\n      (top ?d ?from)\n      (on-disk ?d ?under)\n      (top ?dsttop ?to)\n      (clear ?d)\n      (smaller ?d ?dsttop)\n    )\n    :effect (and\n      (not (on-disk ?d ?under))\n      (not (top ?d ?from))\n      (top ?under ?from)\n      (clear ?under)\n      (not (top ?dsttop ?to))\n      (not (clear ?dsttop))\n      (on-disk ?d ?dsttop)\n      (top ?d ?to)\n    )\n  )\n)",
    "pddl_problem": "(define (problem hanoi-4-instance0)\n  (:domain hanoi-4)\n  (:objects\n    left middle right - peg\n    A B C D - disk\n  )\n\n  (:init\n    ; initial stack on left (top -> bottom): A B C D\n    (on-disk A B)\n    (on-disk B C)\n    (on-disk C D)\n    (on-peg D left)\n    (top A left)\n    (empty middle)\n    (empty right)\n    (clear A)\n    ; size ordering (A smallest, D largest)\n    (smaller A B) (smaller A C) (smaller A D)\n    (smaller B C) (smaller B D)\n    (smaller C D)\n  )\n\n  (:goal (and\n    ; goal: right peg has stack top->bottom A B C D and other pegs empty\n    (on-disk A B)\n    (on-disk B C)\n    (on-disk C D)\n    (on-peg D right)\n    (top A right)\n    (empty left)\n    (empty middle)\n  ))\n)",
    "target_solver": "FastDownwards",
    "pddl_plan": "(move-disk-to-empty a b left middle)\n(move-disk-to-empty b c left right)\n(move-peg-to-disk a middle right b)\n(move-disk-to-empty c d left middle)\n(move-disk-to-disk a b right left d)\n(move-peg-to-disk b right middle c)\n(move-disk-to-disk a d left middle b)\n(move-peg-to-empty d left right)\n(move-disk-to-disk a b middle right d)\n(move-disk-to-empty b c middle left)\n(move-disk-to-disk a d right left b)\n(move-peg-to-disk c middle right d)\n(move-disk-to-disk a b left right c)\n(move-disk-to-empty a c right middle)\n(move-peg-to-disk b left right c)\n(move-peg-to-disk a middle right b)\n; cost = 16 (unit cost)\n",
    "syntax_errors": "No syntax error log was generated.",
    "pddl_logs": "INFO     planner time limit: None\nINFO     planner memory limit: None\n\nINFO     Running translator.\nINFO     translator stdin: None\nINFO     translator time limit: None\nINFO     translator memory limit: None\nINFO     translator command line string: /home/emanuele/MultiAgentPlanning/.venv/bin/python3 /home/emanuele/MultiAgentPlanning/solvers/fast-downward-24.06.1/builds/release/bin/translate/translate.py results/hanoi_scaling/hanoi_4_disks/hanoi_4_disks/FastDownwards/Hanoi4Instance0/domain_1.pddl results/hanoi_scaling/hanoi_4_disks/hanoi_4_disks/FastDownwards/Hanoi4Instance0/problem_1.pddl --sas-file output.sas\nParsing...\nParsing: [0.000s CPU, 0.002s wall-clock]\nNormalizing task... [0.000s CPU, 0.000s wall-clock]\nInstantiating...\nGenerating Datalog program... [0.000s CPU, 0.000s wall-clock]\nNormalizing Datalog program...\nNormalizing Datalog program: [0.010s CPU, 0.002s wall-clock]\nPreparing model... [0.000s CPU, 0.001s wall-clock]\nGenerated 45 rules.\nComputing model... [0.000s CPU, 0.005s wall-clock]\n335 relevant atoms\n270 auxiliary atoms\n605 final queue length\n1566 total queue pushes\nCompleting instantiation... [0.010s CPU, 0.012s wall-clock]\nInstantiating: [0.020s CPU, 0.020s wall-clock]\nComputing fact groups...\nFinding invariants...\n13 initial candidates\nFinding invariants: [0.010s CPU, 0.005s wall-clock]\nChecking invariant weight... [0.000s CPU, 0.000s wall-clock]\nInstantiating groups... [0.000s CPU, 0.000s wall-clock]\nCollecting mutex groups... [0.000s CPU, 0.000s wall-clock]\nChoosing groups...\n4 uncovered facts\nChoosing groups: [0.000s CPU, 0.000s wall-clock]\nBuilding translation key... [0.000s CPU, 0.000s wall-clock]\nComputing fact groups: [0.010s CPU, 0.005s wall-clock]\nBuilding STRIPS to SAS dictionary... [0.000s CPU, 0.000s wall-clock]\nBuilding dictionary for full mutex groups... [0.000s CPU, 0.000s wall-clock]\nBuilding mutex information...\nBuilding mutex information: [0.000s CPU, 0.000s wall-clock]\nTranslating task...\nProcessing axioms...\nSimplifying axioms... [0.000s CPU, 0.000s wall-clock]\nTranslator axioms removed by simplifying: 0\nProcessing axioms: [0.000s CPU, 0.001s wall-clock]\nTranslating task: [0.010s CPU, 0.008s wall-clock]\n84 effect conditions simplified\n0 implied preconditions added\nDetecting unreachable propositions...\n0 operators removed\n0 axioms removed\n4 propositions removed\nDetecting unreachable propositions: [0.000s CPU, 0.003s wall-clock]\nReordering and filtering variables...\n11 of 11 variables necessary.\n12 of 14 mutex groups necessary.\n144 of 144 operators necessary.\n0 of 0 axiom rules necessary.\nReordering and filtering variables: [0.000s CPU, 0.002s wall-clock]\nTranslator variables: 11\nTranslator derived variables: 0\nTranslator facts: 45\nTranslator goal facts: 7\nTranslator mutex groups: 12\nTranslator total mutex groups size: 57\nTranslator operators: 144\nTranslator axioms: 0\nTranslator task size: 1440\nTranslator peak memory: 32588 KB\nWriting output... [0.000s CPU, 0.001s wall-clock]\nDone! [0.040s CPU, 0.043s wall-clock]\ntranslate exit code: 0\n\nINFO     Running search (release).\nINFO     search stdin: output.sas\nINFO     search time limit: None\nINFO     search memory limit: None\nINFO     search command line string: /home/emanuele/MultiAgentPlanning/solvers/fast-downward-24.06.1/builds/release/bin/downward --search 'let(hlm,landmark_sum(lm_factory=lm_reasonable_orders_hps(lm_rhw()),transform=adapt_costs(one),pref=false),let(hff,ff(transform=adapt_costs(one)),lazy_greedy([hff,hlm],preferred=[hff,hlm],cost_type=one,reopen_closed=false)))' --internal-plan-file results/hanoi_scaling/hanoi_4_disks/hanoi_4_disks/FastDownwards/Hanoi4Instance0/sas_plan_1 < output.sas\n[t=0.000241s, 9964 KB] reading input...\n[t=0.001649s, 9964 KB] done reading input!\n[t=0.003552s, 10360 KB] Initializing landmark sum heuristic...\n[t=0.003626s, 10360 KB] Generating landmark graph...\n[t=0.003677s, 10360 KB] Building a landmark graph with reasonable orders.\n[t=0.003720s, 10360 KB] Initializing Exploration...\n[t=0.003847s, 10360 KB] Generating landmarks using the RPG/SAS+ approach\n[t=0.004991s, 10360 KB] Landmarks generation time: 0.001321s\n[t=0.005247s, 10360 KB] Discovered 19 landmarks, of which 2 are disjunctive and 0 are conjunctive.\n[t=0.005268s, 10360 KB] 33 edges\n[t=0.005284s, 10360 KB] approx. reasonable orders\n[t=0.006100s, 10360 KB] Landmarks generation time: 0.002470s\n[t=0.006117s, 10360 KB] Discovered 19 landmarks, of which 2 are disjunctive and 0 are conjunctive.\n[t=0.006131s, 10360 KB] 41 edges\n[t=0.006145s, 10360 KB] Landmark graph generation time: 0.002533s\n[t=0.006161s, 10360 KB] Landmark graph contains 19 landmarks, of which 2 are disjunctive and 0 are conjunctive.\n[t=0.006176s, 10360 KB] Landmark graph contains 41 orderings.\n[t=0.006334s, 10360 KB] Simplifying 678 unary operators... done! [678 unary operators]\n[t=0.006902s, 10360 KB] time to simplify: 0.000610s\n[t=0.006988s, 10360 KB] Initializing additive heuristic...\n[t=0.007010s, 10360 KB] Initializing FF heuristic...\n[t=0.007068s, 10360 KB] Building successor generator...done!\n[t=0.007219s, 10360 KB] peak memory difference for successor generator creation: 0 KB\n[t=0.007235s, 10360 KB] time for successor generation creation: 0.000104s\n[t=0.007252s, 10360 KB] Variables: 11\n[t=0.007267s, 10360 KB] FactPairs: 45\n[t=0.007281s, 10360 KB] Bytes per state: 4\n[t=0.007326s, 10360 KB] Conducting lazy best first search, (real) bound = 2147483647\n[t=0.007395s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 10\n[t=0.007415s, 10360 KB] New best heuristic value for ff: 6\n[t=0.007429s, 10360 KB] g=0, 1 evaluated, 0 expanded\n[t=0.007450s, 10360 KB] Initial heuristic value for landmark_sum_heuristic: 10\n[t=0.007465s, 10360 KB] Initial heuristic value for ff: 6\n[t=0.007500s, 10360 KB] New best heuristic value for ff: 5\n[t=0.007514s, 10360 KB] g=1, 2 evaluated, 1 expanded\n[t=0.007590s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 8\n[t=0.007605s, 10360 KB] g=3, 5 evaluated, 4 expanded\n[t=0.007637s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 7\n[t=0.007652s, 10360 KB] g=4, 6 evaluated, 5 expanded\n[t=0.007755s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 5\n[t=0.007770s, 10360 KB] g=7, 11 evaluated, 10 expanded\n[t=0.007802s, 10360 KB] New best heuristic value for landmark_sum_heuristic: 3\n[t=0.007816s, 10360 KB] New best heuristic value for ff: 3\n[t=0.007830s, 10360 KB] g=8, 12 evaluated, 11 expanded\n[t=0.008043s, 10360 KB] New best heuristic value for ff: 2\n[t=0.008059s, 10360 KB] g=12, 24 evaluated, 23 expanded\n[t=0.008125s, 10360 KB] Solution found!\n[t=0.008141s, 10360 KB] Actual search time: 0.000794s\nmove-disk-to-empty a b left middle (1)\nmove-disk-to-empty b c left right (1)\nmove-peg-to-disk a middle right b (1)\nmove-disk-to-empty c d left middle (1)\nmove-disk-to-disk a b right left d (1)\nmove-peg-to-disk b right middle c (1)\nmove-disk-to-disk a d left middle b (1)\nmove-peg-to-empty d left right (1)\nmove-disk-to-disk a b middle right d (1)\nmove-disk-to-empty b c middle left (1)\nmove-disk-to-disk a d right left b (1)\nmove-peg-to-disk c middle right d (1)\nmove-disk-to-disk a b left right c (1)\nmove-disk-to-empty a c right middle (1)\nmove-peg-to-disk b left right c (1)\nmove-peg-to-disk a middle right b (1)\n[t=0.008156s, 10360 KB] Plan length: 16 step(s).\n[t=0.008156s, 10360 KB] Plan cost: 16\n[t=0.008156s, 10360 KB] Expanded 28 state(s).\n[t=0.008156s, 10360 KB] Reopened 0 state(s).\n[t=0.008156s, 10360 KB] Evaluated 29 state(s).\n[t=0.008156s, 10360 KB] Evaluations: 58\n[t=0.008156s, 10360 KB] Generated 83 state(s).\n[t=0.008156s, 10360 KB] Dead ends: 0 state(s).\n[t=0.008156s, 10360 KB] Number of registered states: 29\n[t=0.008156s, 10360 KB] Int hash set load factor: 29/32 = 0.906250\n[t=0.008156s, 10360 KB] Int hash set resizes: 5\n[t=0.008156s, 10360 KB] Search time: 0.000831s\n[t=0.008156s, 10360 KB] Total time: 0.008156s\nSolution found.\nPeak memory: 10360 KB\nRemove intermediate file output.sas\nsearch exit code: 0\n\nINFO     Planner time: 0.15s\n",
    "history": [
        "AgentSolutionFirst"
    ],
    "proposed_solution": "1. Move A from left to middle\n2. Move B from left to right\n3. Move A from middle to right\n4. Move C from left to middle\n5. Move A from right to left\n6. Move B from right to middle\n7. Move A from left to middle\n8. Move D from left to right\n9. Move A from middle to right\n10. Move B from middle to left\n11. Move A from right to left\n12. Move C from middle to right\n13. Move A from left to middle\n14. Move B from left to right\n15. Move A from middle to right"
}
================================================================================


NATURAL-PLAN sas_plan_1
------------------------------
Below is a human-readable, step-by-step execution of the provided plan. Each step corresponds exactly to one action in the plan (same order, same moves). I give an estimated timestamp and a per-move duration (30 s each) so you can track timing; total estimated time = 8:00.

1. [t = 00:00:00, dur 00:00:30] move-disk-to-empty a b left → middle
   - Move disk A (currently on top of B on the left peg) from the left peg to the middle peg (middle peg is empty).

2. [t = 00:00:30, dur 00:00:30] move-disk-to-empty b c left → right
   - Move disk B (currently on top of C on the left peg) from the left peg to the right peg (right peg is empty).

3. [t = 00:01:00, dur 00:00:30] move-peg-to-disk a middle → right on B
   - Move disk A (top of middle peg) from the middle peg to the right peg, placing it onto disk B.

4. [t = 00:01:30, dur 00:00:30] move-disk-to-empty c d left → middle
   - Move disk C (currently on top of D on the left peg) from the left peg to the middle peg (middle peg is empty after step 3).

5. [t = 00:02:00, dur 00:00:30] move-disk-to-disk a b right → left on D
   - Move disk A (top of right peg, on B) from the right peg to the left peg, placing it onto disk D.

6. [t = 00:02:30, dur 00:00:30] move-peg-to-disk b right → middle on C
   - Move disk B (top of right peg) from the right peg to the middle peg, placing it onto disk C.

7. [t = 00:03:00, dur 00:00:30] move-disk-to-disk a d left → middle on B
   - Move disk A (top of left peg, on D) from the left peg to the middle peg, placing it onto disk B.

8. [t = 00:03:30, dur 00:00:30] move-peg-to-empty d left → right
   - Move disk D (currently on the left peg and is the bottom disk there) from the left peg to the right peg (right peg becomes non-empty).

9. [t = 00:04:00, dur 00:00:30] move-disk-to-disk a b middle → right on D
   - Move disk A (top of middle peg, on B) from the middle peg to the right peg, placing it onto disk D.

10. [t = 00:04:30, dur 00:00:30] move-disk-to-empty b c middle → left
    - Move disk B (top of middle peg, on C) from the middle peg to the left peg (left peg is empty after D moved).

11. [t = 00:05:00, dur 00:00:30] move-disk-to-disk a d right → left on B
    - Move disk A (top of right peg, on D) from the right peg to the left peg, placing it onto disk B.

12. [t = 00:05:30, dur 00:00:30] move-peg-to-disk c middle → right on D
    - Move disk C (top of middle peg) from the middle peg to the right peg, placing it onto disk D.

13. [t = 00:06:00, dur 00:00:30] move-disk-to-disk a b left → right on C
    - Move disk A (top of left peg, on B) from the left peg to the right peg, placing it onto disk C.

14. [t = 00:06:30, dur 00:00:30] move-disk-to-empty a c right → middle
    - Move disk A (top of right peg, on C) from the right peg to the middle peg (middle peg becomes non-empty).

15. [t = 00:07:00, dur 00:00:30] move-peg-to-disk b left → right on C
    - Move disk B (top of left peg) from the left peg to the right peg, placing it onto disk C.

16. [t = 00:07:30, dur 00:00:30] move-peg-to-disk a middle → right on B
    - Move disk A (top of middle peg) from the middle peg to the right peg, placing it onto disk B.

End state (after t = 00:08:00): right peg has disks top→bottom A, B, C, D; left and middle pegs are empty — goal achieved.

(Each step above corresponds exactly to the plan lines provided and respects the Hanoi constraints: single-disk moves and never placing a larger disk on a smaller one.)
================================================================================

