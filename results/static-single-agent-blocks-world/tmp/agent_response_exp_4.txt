Below is a **complete pair of PDDL files** that model the situation you described and give a goal that matches exactly the final configuration stated in the prompt.

---

### Domain file – `blockworld-domain.pddl`

```pddl
(define (domain blockworld)
  (:requirements :typing :equality)

  (:types block)

  (:constants table)

  ;; ----- Predicates -----
  ;;  on ?x ?y  :  ?x is sitting on ?y (where ?y can be a block or the table)
  ;;  clear ?x :  no block is on top of ?x
  (:predicates
    (on ?x - block ?y - (either block table))
    (clear ?x - (either block table))
  )

  ;; ----- Actions -----
  ;;  Move a clear block onto another clear block or onto the table.
  (:action move
    :parameters (?b - block ?from - (either block table) ?to   - (either block table))
    :preconditions (and
                     (clear ?b)
                     (on ?b ?from)
                     (clear ?to)
                     (not (= ?b ?to))          ; cannot move a block onto itself
                    )
    :effects (and
                (not (on ?b ?from))           ; it is no longer on the old support
                (on ?b ?to)                   ; it is on the new support
                (clear ?from)                 ; the block beneath becomes clear
                (not (clear ?to))             ; the new support is no longer clear
              )
  )
)
```

**Explanation**

* We treat the table as a special constant that can appear in the predicate `on`.  
* The only state‐changing action is `move`.  
  * Preconditions guarantee the block being moved is clear, is on something, and that the target is clear.  
  * The effects correctly update the “on/clear” relationships for the moved block, its old support, and its new support.

---

### Problem file – `blockworld-problem.pddl`

```pddl
(define (problem blockworld-setup)
  (:domain blockworld)

  (:objects
     A B C D E  - block
     table      - table
  )

  (:init
     ;; Initial configuration – every block is on the table and clear
     (on A table)  (clear A)
     (on B table)  (clear B)
     (on C table)  (clear C)
     (on D table)  (clear D)
     (on E table)  (clear E)

     ;; The table is always clear – we need it as a precondition target
     (clear table)
  )

  (:goal (and
            (on E table)
            (on D E)
            (on B D)
            (on C B)
            (clear C)
            (on A table)
            (clear A)
          ))
)
```

**Explanation**

* All five blocks start isolated on the table and clear.  
* The goal encodes exactly the stack `E‑D‑B‑C` with `C` clear, and lets `A` stay alone on the table and clear.  

---

With these files any compliant PDDL planner will generate a sequence of `move` actions that rearranges the five blocks into the required final configuration.