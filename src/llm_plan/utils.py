import string
import subprocess
from pathlib import Path
from typing import Any, List, Dict

from src.llm_plan.config import (
    UNIVERSAL_VALIDATOR_BIN,
    SOLVER_BINARY,
    SOLVER_ARGS,
)


def get_fields_in_formatted_string(formatted_string: str) -> list[str]:
    """Extract field names from a formatted string.
    Example:
        >>> get_fields_in_formatted_string("Hello, {name}! Today is {day}.")
        ['name', 'day']
    """
    formatter = string.Formatter()
    return [
        fname
        for _, fname, _, _ in formatter.parse(formatted_string)
        if fname is not None
    ]


def get_json_nested_fields(data: Dict[str, Any], keys: List[str]) -> Any:
    """
    Retrieve a nested value from a dictionary given a list of keys.

    Example:
        get_nested({"a": {"b": {"c": 1}}}, ["a", "b", "c"]) -> 1
    """
    for k in keys:
        data = data[k]
    return data


def run_pddl_fast_downwards_and_uVal(
    base_folder: Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path = "sas_plan",
) -> dict[str, str]:
    """Run Fast Downwards and uVal on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary files
        domain_path (str | Path): the path to the PDDL domain file
        problem_path (str | Path): the path to the PDDL problem file
        sas_plan_path (str | Path, optional): the path to the output plan file. Defaults to "sas_plan".

    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by Fast Downwards, or a message if no plan was found
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated
            - "pddl_logs": the logs generated by Fast Downwards, or a message if no log was generated
    """
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }

    # Launch the solver (Fast Downwards)
    command = [
        SOLVER_BINARY,
        *SOLVER_ARGS,
        sas_plan_path,
        domain_path,
        problem_path,
    ]

    # Write and then read the logs file
    with open(base_folder / "logs.txt", "w+") as logfile:
        subprocess.run(command, stdout=logfile, stderr=subprocess.STDOUT)
        logfile.seek(0)  # go back to the beginning
        result["pddl_logs"] = logfile.read()

    if Path(base_folder / sas_plan_path).exists():
        result["pddl_plan"] = open(Path(base_folder / sas_plan_path)).read()

    # Validate the plan with uVal
    command = f"{UNIVERSAL_VALIDATOR_BIN} -cv \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result


def run_pddl_popf2_and_Val(
    base_folder: Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path = "sas_plan",
) -> dict[str, str]:
    """Run Fast Downwards and uVal on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary files
        domain_path (str | Path): the path to the PDDL domain file
        problem_path (str | Path): the path to the PDDL problem file
        sas_plan_path (str | Path, optional): the path to the output plan file. Defaults to "sas_plan".

    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by POPF2, or a message if no plan was found
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated
            - "pddl_logs": the logs generated by POPF2, or a message if no log was generated
    """
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }

    # Launch the solver (POPF2)
    command = [
        SOLVER_BINARY,
        *SOLVER_ARGS,
        domain_path,
        problem_path,
        "&>",
        sas_plan_path,
    ]

    # Write the plan and then read the logs file
    subprocess.run(command, stderr=subprocess.STDOUT)

    if Path(base_folder / sas_plan_path).exists():
        result["pddl_plan"] = open(Path(base_folder / sas_plan_path)).read()

    result["pddl_logs"] = (
        "POPF2 does not generate a log file, so just ignore this message."
    )

    # Validate the plan with POPF2
    command = f"{UNIVERSAL_VALIDATOR_BIN} \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result
