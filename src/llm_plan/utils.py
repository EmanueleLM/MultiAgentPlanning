import os
import re
import string
import subprocess
import sys
import time
from pathlib import Path
from typing import Any, List, Dict


def _config():
    from src.llm_plan import config as cfg
    return cfg


def collect_debug_logs(field_name:str, content:str):
    highlight = "\n" + "-" * 30 + "\n"
    separator = "\n" + "=" * 80 + "\n\n"
    return field_name + highlight + content + separator


def get_fields_in_formatted_string(formatted_string: str) -> list[str]:
    """Extract field names from a formatted string.
    Example:
        >>> get_fields_in_formatted_string("Hello, {name}! Today is {day}.")
        ['name', 'day']
    """
    formatter = string.Formatter()
    return [
        fname
        for _, fname, _, _ in formatter.parse(formatted_string)
        if fname is not None
    ]


def get_json_nested_fields(data: Dict[str, Any], keys: List[str]) -> Any:
    """
    Retrieve a nested value from a dictionary given a list of keys.

    Example:
        get_nested({"a": {"b": {"c": 1}}}, ["a", "b", "c"]) -> 1
    """
    for k in keys:
        data = data[k]
    return data

def get_latest_file(
    folder: str | Path, 
    prefix: str, 
    regexp: str = r'(\d+)$'
    ) -> tuple[str, int] | None:
    """_summary_

    Args:
        folder (str | Path): _description_
        prefix (str): _description_
        regexp (str, optional): _description_. Defaults to r'(\d+)$'.

    Returns:
        str | None: _description_
    """
    # Produce the natural language plan
    plan_files = [f for f in os.listdir(folder) if f.startswith(prefix)]
    
    if not plan_files:
        return None, None  # No plan files found
        # Get the latest plan
        
    numbers = []
    for f in plan_files:
        match = re.search(regexp, f)  # match number at the end
        if match:
            numbers.append((f, int(match.group(1))))
        
        highest_file, highest_number = max(numbers, key=lambda x: x[1])
    
    return highest_file, highest_number


global_timeout = 10 * 60  # seconds
_subprocess_execution_times: list[float] = []


class SubprocessGlobalTimeoutError(RuntimeError):
    """Raised when an individual subprocess.run call exceeds the global timeout."""

    def __init__(self, elapsed_seconds: float, command_repr: str):
        self.elapsed_seconds = elapsed_seconds
        self.command_repr = command_repr
        super().__init__(
            f"Subprocess exceeded global timeout ({elapsed_seconds:.2f}s): {command_repr}"
        )


def _format_command_for_logging(command: Any) -> str:
    if isinstance(command, (list, tuple)):
        return " ".join(map(str, command))
    return str(command)


def _run_with_global_timer(*args, **kwargs) -> subprocess.CompletedProcess:
    """
    Wrap subprocess.run to measure execution time and enforce the global timeout.
    """
    command = kwargs.get("args")
    if command is None and args:
        command = args[0]
    command_repr = _format_command_for_logging(command)

    start = time.monotonic()
    proc = subprocess.run(*args, **kwargs)
    elapsed = time.monotonic() - start
    _subprocess_execution_times.append(elapsed)
    print(
        f"[GlobalTimer] Command finished in {elapsed:.2f}s "
        f"(threshold {global_timeout}s): {command_repr}"
    )

    if elapsed > global_timeout:
        raise SubprocessGlobalTimeoutError(elapsed, command_repr)

    return proc


def _timeout_result() -> dict[str, str]:
    return {
        "pddl_plan": "Timeout. FastDownwards took too long to finish. In the next call, you should generate a domain and problem with less variables. You can use AgentReduceVariables to achieve that.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }


def run_pddl_fast_downwards_and_uVal(
    base_folder: Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path,
    optimize: int = 0,
) -> dict[str, str]:
    """Run Fast Downwards and uVal on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary logs.
        domain_path (Path): the path to the PDDL domain file.
        problem_path (Path): the path to the PDDL problem file.
        sas_plan_path (Path, optional): the path to the output plan file. Defaults to "sas_plan".
        optimize (int, optional): the optimization level for Fast Downwards. Defaults to 0.
        
    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by Fast Downwards, or a message if no plan was found.
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated.
            - "pddl_logs": the logs generated by Fast Downwards, or a message if no log was generated.
    """
    print(f"Running Fast Downwards and uVAL in {base_folder}.")

    cfg = _config()
    solver_fd_binary = cfg.SOLVER_FD_BINARY
    solver_fd_args = cfg.SOLVER_FD_ARGS
    solver_fd_optimize_args = cfg.SOLVER_FD_OPTIMIZE_ARGS
    universal_validator_bin = cfg.UNIVERSAL_VALIDATOR_BIN

    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }
    try:
        with open(base_folder / "logs.txt", "w+") as logfile:
            # No optimization
            if optimize == 0:
                print("Running command with no optimization.")
                command = [
                    str(solver_fd_binary),
                    *map(str, solver_fd_args),
                    str(sas_plan_path),
                    str(domain_path),
                    str(problem_path),
                ]

                _run_with_global_timer(
                    command,
                    stdout=logfile,
                    stderr=subprocess.STDOUT
                )
            # Optimization for int(optimize) seconds
            else:
                try:
                    print(f"Running command with optimization timeout = {optimize} [s].")
                    optimize_args = list(solver_fd_optimize_args) or [
                        "--search",
                        "astar(lmcut())",
                        "--plan-file",
                    ]
                    command = [
                        sys.executable,
                        str(solver_fd_binary),
                        *optimize_args,
                        str(sas_plan_path),
                        str(domain_path),
                        str(problem_path),
                    ]

                    print("COMMAND:", command)
                    proc = _run_with_global_timer(
                        command,
                        stdout=logfile,
                        stderr=subprocess.STDOUT,
                        timeout=optimize
                    )
                    if proc.returncode == 0:
                        print("Optimization completed successfully!")
                        logfile.seek(0, os.SEEK_END)
                    else:
                        logfile.flush()
                        logfile.seek(0)
                        snapshot = logfile.read()
                        quoting_bug = (
                            "FileNotFoundError" in snapshot and "astar(lmcut())" in snapshot
                        )
                        if quoting_bug:
                            print(
                                "Detected Fast Downward quoting issue for --search argument; retrying without optimization flags."
                            )
                            logfile.seek(0)
                            logfile.truncate()
                            fallback_command = [
                                str(solver_fd_binary),
                                *map(str, solver_fd_args),
                                str(sas_plan_path),
                                str(domain_path),
                                str(problem_path),
                            ]
                            _run_with_global_timer(
                                fallback_command,
                                stdout=logfile,
                                stderr=subprocess.STDOUT,
                            )
                        else:
                            logfile.seek(0, os.SEEK_END)

                # If the optimization times out, run without optimization
                except subprocess.TimeoutExpired:
                    print("Optimization timed out, running without optimization.")
                    command = [
                        str(solver_fd_binary),
                        *map(str, solver_fd_args),
                        str(sas_plan_path),
                        str(domain_path),
                        str(problem_path),
                    ]
                    _run_with_global_timer(
                        command,
                        stdout=logfile,
                        stderr=subprocess.STDOUT
                    )

            logfile.seek(0)
            result["pddl_logs"] = logfile.read()

        if Path(sas_plan_path).exists():
            result["pddl_plan"] = open(Path(sas_plan_path)).read()

        # Validate the plan with uVal
        command = f"{universal_validator_bin} -cv \
            {domain_path} \
            {problem_path} \
            {sas_plan_path}"

        out = _run_with_global_timer(
            command,
            shell=True,
            capture_output=True,
            text=True
        )

        if out.stderr:
            result["syntax_errors"] = out.stderr

        return result

    except SubprocessGlobalTimeoutError as exc:
        print(
            f"[GlobalTimer] Timeout triggered after {exc.elapsed_seconds:.2f}s. "
            f"Command: {exc.command_repr}"
        )
        timeout_result = _timeout_result()
        return timeout_result


def run_pddl_popf2_and_Val(
    base_folder: str | Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path,
    optimize: int = 0,
) -> dict[str, str]:
    """Run POPF2 and Val on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary logs. Kept for compatibility.
        domain_path (Path): the path to the PDDL domain file.
        problem_path (Path): the path to the PDDL problem file.
        sas_plan_path (Path, optional): the path to the output plan file. Defaults to "sas_plan".
        optimize (int, optional): the optimization level for POPF2. Defaults to 0. Kept for compatibility.
        
    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by POPF2, or a message if no plan was found.
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated.
            - "pddl_logs": the logs generated by POPF2, or a message if no log was generated.
    """
    print(f"Running POPF2 and VAL in {base_folder}.")

    cfg = _config()
    solver_popf2_binary = cfg.SOLVER_POPF2_BINARY
    validator_bin = cfg.VALIDATOR_BIN
    
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }

    # Launch the solver (POPF2)
    command = [
        str(solver_popf2_binary),
        domain_path,
        problem_path
    ]

    out = subprocess.run(
        command,
        capture_output=True,  # captures both stdout and stderr
        text=True
    )

    print("STDOUT:\n", out.stdout)
    print("STDERR:\n", out.stderr)
    print("Return Code:", out.returncode, type(out.returncode))
    
    # Store plan, errors and logs
    if out.returncode == 0:  # Success
        result["pddl_plan"] = out.stdout
        with open(sas_plan_path, "w") as f:
            f.write(out.stdout)
    
    result["pddl_logs"] = {
        "stdout": out.stdout,
        "stderr": out.stderr             
    }
    result["pddl_logs"] = str(result["pddl_logs"])  # Cast to string for compatibility with the prompt

    # Validate the plan with POPF2
    command = f"{validator_bin} \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result
