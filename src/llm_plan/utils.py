import os
import re
import string
import subprocess
from pathlib import Path
from typing import Any, List, Dict

from src.llm_plan.config import (
    SOLVER_POPF2_BINARY,
    SOLVER_FD_BINARY,
    SOLVER_FD_ARGS,
    SOLVER_FD_OPTIMIZE_ARGS,
    VALIDATOR_BIN,
    UNIVERSAL_VALIDATOR_BIN
)


def collect_debug_logs(field_name:str, content:str):
    highlight = "\n" + "-" * 30 + "\n"
    separator = "\n" + "=" * 80 + "\n\n"
    return field_name + highlight + content + separator


def get_fields_in_formatted_string(formatted_string: str) -> list[str]:
    """Extract field names from a formatted string.
    Example:
        >>> get_fields_in_formatted_string("Hello, {name}! Today is {day}.")
        ['name', 'day']
    """
    formatter = string.Formatter()
    return [
        fname
        for _, fname, _, _ in formatter.parse(formatted_string)
        if fname is not None
    ]


def get_json_nested_fields(data: Dict[str, Any], keys: List[str]) -> Any:
    """
    Retrieve a nested value from a dictionary given a list of keys.

    Example:
        get_nested({"a": {"b": {"c": 1}}}, ["a", "b", "c"]) -> 1
    """
    for k in keys:
        data = data[k]
    return data

def get_latest_file(
    folder: str | Path, 
    prefix: str, 
    regexp: str = r'(\d+)$'
    ) -> tuple[str, int] | None:
    """_summary_

    Args:
        folder (str | Path): _description_
        prefix (str): _description_
        regexp (str, optional): _description_. Defaults to r'(\d+)$'.

    Returns:
        str | None: _description_
    """
    # Produce the natural language plan
    plan_files = [f for f in os.listdir(folder) if f.startswith(prefix)]
    
    if not plan_files:
        return None, None  # No plan files found
        # Get the latest plan
        
    numbers = []
    for f in plan_files:
        match = re.search(regexp, f)  # match number at the end
        if match:
            numbers.append((f, int(match.group(1))))
        
        highest_file, highest_number = max(numbers, key=lambda x: x[1])
    
    return highest_file, highest_number


def run_pddl_fast_downwards_and_uVal(
    base_folder: Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path,
    optimize: int = 0,
) -> dict[str, str]:
    """Run Fast Downwards and uVal on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary logs.
        domain_path (Path): the path to the PDDL domain file.
        problem_path (Path): the path to the PDDL problem file.
        sas_plan_path (Path, optional): the path to the output plan file. Defaults to "sas_plan".
        optimize (int, optional): the optimization level for Fast Downwards. Defaults to 0.
        
    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by Fast Downwards, or a message if no plan was found.
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated.
            - "pddl_logs": the logs generated by Fast Downwards, or a message if no log was generated.
    """
    print(f"Running Fast Downwards and uVAL in {base_folder}.")
    
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }
        
    with open(base_folder / "logs.txt", "w+") as logfile:
        # No optimization
        if optimize == 0:
            print("Running command with no optimization.")
            command = [
                SOLVER_FD_BINARY,
                *SOLVER_FD_ARGS,
                sas_plan_path,
                domain_path,
                problem_path,
            ]
            subprocess.run(
                command,
                stdout=logfile,
                stderr=subprocess.STDOUT,
                timeout=optimize
            )
        # Optimization for int(optimize) seconds
        else:
            try:
                print(f"Running command with optimization timeout = {optimize} [s].")
                command = [
                    SOLVER_FD_BINARY,
                    *SOLVER_FD_OPTIMIZE_ARGS,
                    sas_plan_path,
                    domain_path,
                    problem_path,
                ]
                subprocess.run(
                    command,
                    stdout=logfile,
                    stderr=subprocess.STDOUT,
                    timeout=optimize
                )
                print("Optimization completed successfully!")
                
            # If the optimization times out, run without optimization  
            except subprocess.TimeoutExpired:
                print("Optimization timed out, running without optimization.")
                command = [
                    SOLVER_FD_BINARY,
                    *SOLVER_FD_ARGS,
                    sas_plan_path,
                    domain_path,
                    problem_path,
                ]
                subprocess.run(
                    command,
                    stdout=logfile,
                    stderr=subprocess.STDOUT
                )

        logfile.seek(0)
        result["pddl_logs"] = logfile.read()

    if Path(sas_plan_path).exists():
        result["pddl_plan"] = open(Path(sas_plan_path)).read()

    # Validate the plan with uVal
    command = f"{UNIVERSAL_VALIDATOR_BIN} -cv \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result


def run_pddl_popf2_and_Val(
    base_folder: str | Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path,
    optimize: int = 0,
) -> dict[str, str]:
    """Run POPF2 and Val on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary logs. Kept for compatibility.
        domain_path (Path): the path to the PDDL domain file.
        problem_path (Path): the path to the PDDL problem file.
        sas_plan_path (Path, optional): the path to the output plan file. Defaults to "sas_plan".
        optimize (int, optional): the optimization level for POPF2. Defaults to 0. Kept for compatibility.
        
    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by POPF2, or a message if no plan was found.
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated.
            - "pddl_logs": the logs generated by POPF2, or a message if no log was generated.
    """
    print(f"Running POPF2 and VAL in {base_folder}.")
    
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }

    # Launch the solver (POPF2)
    command = [
        SOLVER_POPF2_BINARY,
        domain_path,
        problem_path
    ]

    out = subprocess.run(
        command,
        capture_output=True,  # captures both stdout and stderr
        text=True
    )

    print("STDOUT:\n", out.stdout)
    print("STDERR:\n", out.stderr)
    print("Return Code:", out.returncode, type(out.returncode))
    
    # Store plan, errors and logs
    if out.returncode == 0:  # Success
        result["pddl_plan"] = out.stdout
        with open(sas_plan_path, "w") as f:
            f.write(out.stdout)
    
    result["pddl_logs"] = {
        "stdout": out.stdout,
        "stderr": out.stderr             
    }
    result["pddl_logs"] = str(result["pddl_logs"])  # Cast to string for compatibility with the prompt

    # Validate the plan with POPF2
    command = f"{VALIDATOR_BIN} \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result
