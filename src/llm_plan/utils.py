import string
import subprocess
from pathlib import Path
from typing import Any, List, Dict

from src.llm_plan.config import (
    SOLVER_POPF2_BINARY,
    SOLVER_FD_BINARY,
    SOLVER_FD_ARGS,
    VALIDATOR_BIN,
    UNIVERSAL_VALIDATOR_BIN
)


def get_fields_in_formatted_string(formatted_string: str) -> list[str]:
    """Extract field names from a formatted string.
    Example:
        >>> get_fields_in_formatted_string("Hello, {name}! Today is {day}.")
        ['name', 'day']
    """
    formatter = string.Formatter()
    return [
        fname
        for _, fname, _, _ in formatter.parse(formatted_string)
        if fname is not None
    ]


def get_json_nested_fields(data: Dict[str, Any], keys: List[str]) -> Any:
    """
    Retrieve a nested value from a dictionary given a list of keys.

    Example:
        get_nested({"a": {"b": {"c": 1}}}, ["a", "b", "c"]) -> 1
    """
    for k in keys:
        data = data[k]
    return data


def run_pddl_fast_downwards_and_uVal(
    base_folder: Path,
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path = "sas_plan",
) -> dict[str, str]:
    """Run Fast Downwards and uVal on the given domain and problem files.

    Args:
        base_folder (Path): the base folder to store temporary files
        domain_path (Path): the path to the PDDL domain file
        problem_path (Path): the path to the PDDL problem file
        sas_plan_path (Path, optional): the path to the output plan file. Defaults to "sas_plan".

    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by Fast Downwards, or a message if no plan was found
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated
            - "pddl_logs": the logs generated by Fast Downwards, or a message if no log was generated
    """
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }

    # Launch the solver (Fast Downwards)
    command = [
        SOLVER_FD_BINARY,
        *SOLVER_FD_ARGS,
        sas_plan_path,
        domain_path,
        problem_path,
    ]

    # Write and then read the logs file
    with open(base_folder / "logs.txt", "w+") as logfile:
        subprocess.run(command, stdout=logfile, stderr=subprocess.STDOUT)
        logfile.seek(0)  # go back to the beginning
        result["pddl_logs"] = logfile.read()

    if Path(sas_plan_path).exists():
        result["pddl_plan"] = open(Path(sas_plan_path)).read()

    # Validate the plan with uVal
    command = f"{UNIVERSAL_VALIDATOR_BIN} -cv \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result


def run_pddl_popf2_and_Val(
    domain_path: str | Path,
    problem_path: str | Path,
    sas_plan_path: str | Path = "sas_plan",
) -> dict[str, str]:
    """Run POPF2 and Val on the given domain and problem files.

    Args:
        domain_path (Path): the path to the PDDL domain file
        problem_path (Path): the path to the PDDL problem file
        sas_plan_path (Path, optional): the path to the output plan file. Defaults to "sas_plan".

    Returns:
        dict[str, str]: a dictionary with keys:
            - "pddl_plan": the plan found by POPF2, or a message if no plan was found
            - "syntax_errors": any syntax errors found in the PDDL files, or a message if no syntax error log was generated
            - "pddl_logs": the logs generated by POPF2, or a message if no log was generated
    """
    result = {
        "pddl_plan": "No plan found.",
        "syntax_errors": "No syntax error log was generated.",
        "pddl_logs": "No log was generated.",
    }

    # Launch the solver (POPF2)
    command = [
        SOLVER_POPF2_BINARY,
        domain_path,
        problem_path
    ]

    out = subprocess.run(
        command,
        capture_output=True,  # captures both stdout and stderr
        text=True
    )

    print("STDOUT:\n", out.stdout)
    print("STDERR:\n", out.stderr)
    print("Return Code:", out.returncode, type(out.returncode))
    
    # Store plan, errors and logs
    if out.returncode == 0:  # Success
        result["pddl_plan"] = out.stdout
        with open(sas_plan_path, "w") as f:
            f.write(out.stdout)
    
    result["pddl_logs"] = {
        "stdout": out.stdout,
        "stderr": out.stderr             
    }
    result["pddl_logs"] = str(result["pddl_logs"])  # Cast to string for compatibility with the prompt

    # Validate the plan with POPF2
    command = f"{VALIDATOR_BIN} \
        {domain_path} \
        {problem_path} \
        {sas_plan_path}"

    out = subprocess.run(command, shell=True, capture_output=True, text=True)

    if out.stderr:
        result["syntax_errors"] = out.stderr

    return result
